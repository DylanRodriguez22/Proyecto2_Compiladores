
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package codigo;

import java_cup.runtime.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\340\000\002\002\004\000\002\004\005\000\002\004" +
    "\005\000\002\004\005\000\002\004\005\000\002\004\003" +
    "\000\002\005\005\000\002\005\005\000\002\005\005\000" +
    "\002\005\005\000\002\005\003\000\002\006\005\000\002" +
    "\006\003\000\002\007\005\000\002\007\003\000\002\010" +
    "\003\000\002\010\003\000\002\010\003\000\002\010\003" +
    "\000\002\010\003\000\002\010\003\000\002\010\003\000" +
    "\002\010\003\000\002\010\004\000\002\002\004\000\002" +
    "\002\004\000\002\003\004\000\002\003\004\000\002\012" +
    "\005\000\002\012\003\000\002\011\005\000\002\011\003" +
    "\000\002\013\005\000\002\013\005\000\002\013\005\000" +
    "\002\013\005\000\002\013\005\000\002\013\005\000\002" +
    "\013\003\000\002\014\003\000\002\014\003\000\002\014" +
    "\003\000\002\015\006\000\002\015\006\000\002\015\006" +
    "\000\002\015\006\000\002\015\006\000\002\015\010\000" +
    "\002\015\010\000\002\015\010\000\002\015\010\000\002" +
    "\015\010\000\002\015\004\000\002\015\006\000\002\015" +
    "\006\000\002\015\006\000\002\015\006\000\002\015\006" +
    "\000\002\015\006\000\002\015\006\000\002\015\006\000" +
    "\002\015\010\000\002\015\010\000\002\015\010\000\002" +
    "\015\010\000\002\015\010\000\002\015\010\000\002\015" +
    "\006\000\002\015\006\000\002\015\006\000\002\015\006" +
    "\000\002\015\006\000\002\015\010\000\002\015\010\000" +
    "\002\015\010\000\002\015\010\000\002\015\010\000\002" +
    "\016\006\000\002\016\006\000\002\016\006\000\002\016" +
    "\006\000\002\017\011\000\002\017\007\000\002\017\011" +
    "\000\002\017\011\000\002\017\011\000\002\017\011\000" +
    "\002\017\011\000\002\017\011\000\002\017\011\000\002" +
    "\017\011\000\002\017\011\000\002\017\011\000\002\017" +
    "\011\000\002\017\011\000\002\017\011\000\002\017\011" +
    "\000\002\017\007\000\002\017\015\000\002\017\015\000" +
    "\002\017\015\000\002\017\015\000\002\017\015\000\002" +
    "\017\015\000\002\017\015\000\002\017\015\000\002\017" +
    "\015\000\002\017\015\000\002\017\015\000\002\017\015" +
    "\000\002\017\015\000\002\017\015\000\002\017\015\000" +
    "\002\017\015\000\002\045\003\000\002\045\003\000\002" +
    "\045\003\000\002\045\005\000\002\045\005\000\002\045" +
    "\005\000\002\020\011\000\002\020\011\000\002\021\006" +
    "\000\002\025\005\000\002\025\005\000\002\025\006\000" +
    "\002\025\005\000\002\026\005\000\002\026\005\000\002" +
    "\026\005\000\002\026\005\000\002\026\005\000\002\026" +
    "\005\000\002\026\005\000\002\064\005\000\002\036\007" +
    "\000\002\037\006\000\002\035\006\000\002\035\007\000" +
    "\002\035\007\000\002\035\010\000\002\035\017\000\002" +
    "\040\003\000\002\040\004\000\002\065\003\000\002\042" +
    "\007\000\002\041\006\000\002\066\003\000\002\043\005" +
    "\000\002\044\006\000\002\067\003\000\002\030\003\000" +
    "\002\027\013\000\002\027\010\000\002\033\003\000\002" +
    "\033\003\000\002\033\004\000\002\033\004\000\002\034" +
    "\004\000\002\070\003\000\002\032\011\000\002\032\011" +
    "\000\002\032\011\000\002\032\011\000\002\031\006\000" +
    "\002\071\003\000\002\072\003\000\002\073\003\000\002" +
    "\074\003\000\002\075\003\000\002\047\004\000\002\047" +
    "\004\000\002\047\004\000\002\047\004\000\002\047\004" +
    "\000\002\046\006\000\002\046\007\000\002\046\007\000" +
    "\002\051\004\000\002\053\002\000\002\053\005\000\002" +
    "\052\004\000\002\052\004\000\002\052\004\000\002\052" +
    "\004\000\002\052\004\000\002\054\004\000\002\054\005" +
    "\000\002\055\005\000\002\055\006\000\002\056\003\000" +
    "\002\056\003\000\002\056\003\000\002\056\003\000\002" +
    "\056\004\000\002\056\004\000\002\056\005\000\002\056" +
    "\005\000\002\056\005\000\002\056\005\000\002\056\005" +
    "\000\002\056\005\000\002\024\005\000\002\024\004\000" +
    "\002\024\005\000\002\023\003\000\002\023\004\000\002" +
    "\022\003\000\002\022\003\000\002\022\003\000\002\022" +
    "\003\000\002\022\003\000\002\022\003\000\002\022\003" +
    "\000\002\022\003\000\002\022\003\000\002\022\003\000" +
    "\002\062\002\000\002\062\004\000\002\061\006\000\002" +
    "\060\004\000\002\050\002\000\002\050\004\000\002\063" +
    "\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0210\000\022\003\uff28\024\uff28\025\uff28\026\uff28\027" +
    "\uff28\030\uff28\031\uff28\033\uff28\001\002\000\022\003\007" +
    "\024\uff24\025\uff24\026\uff24\027\uff24\030\uff24\031\uff24\033" +
    "\012\001\002\000\004\002\006\001\002\000\004\002\001" +
    "\001\002\000\016\024\u0210\025\341\026\345\027\u020f\030" +
    "\342\060\340\001\002\000\016\024\245\025\237\026\244" +
    "\027\234\030\235\031\241\001\002\000\022\003\uff27\024" +
    "\uff27\025\uff27\026\uff27\027\uff27\030\uff27\031\uff27\033\uff27" +
    "\001\002\000\016\003\013\024\020\025\015\026\017\027" +
    "\016\030\014\001\002\000\004\074\227\001\002\000\006" +
    "\003\215\074\216\001\002\000\006\003\202\074\203\001" +
    "\002\000\006\003\171\074\170\001\002\000\006\003\156" +
    "\074\155\001\002\000\006\003\022\074\021\001\002\000" +
    "\006\023\024\060\025\001\002\000\004\060\023\001\002" +
    "\000\046\003\uffcb\007\uffcb\024\uffcb\025\uffcb\026\uffcb\027" +
    "\uffcb\030\uffcb\031\uffcb\033\uffcb\034\uffcb\035\uffcb\037\uffcb" +
    "\040\uffcb\043\uffcb\050\uffcb\051\uffcb\064\uffcb\074\uffcb\001" +
    "\002\000\026\003\047\004\052\013\031\063\046\067\051" +
    "\070\026\071\050\072\045\073\037\074\027\001\002\000" +
    "\046\003\uffd7\007\uffd7\024\uffd7\025\uffd7\026\uffd7\027\uffd7" +
    "\030\uffd7\031\uffd7\033\uffd7\034\uffd7\035\uffd7\037\uffd7\040" +
    "\uffd7\043\uffd7\050\uffd7\051\uffd7\064\uffd7\074\uffd7\001\002" +
    "\000\050\003\ufff1\005\ufff1\010\ufff1\012\ufff1\013\ufff1\014" +
    "\ufff1\015\ufff1\016\ufff1\017\ufff1\020\ufff1\052\ufff1\053\ufff1" +
    "\054\ufff1\055\ufff1\056\ufff1\057\ufff1\060\ufff1\061\ufff1\062" +
    "\ufff1\001\002\000\060\003\ufff0\004\125\005\ufff0\010\ufff0" +
    "\011\130\012\ufff0\013\ufff0\014\ufff0\015\ufff0\016\ufff0\017" +
    "\ufff0\020\ufff0\021\126\022\127\052\ufff0\053\ufff0\054\ufff0" +
    "\055\ufff0\056\ufff0\057\ufff0\060\ufff0\061\ufff0\062\ufff0\001" +
    "\002\000\050\003\uffef\005\uffef\010\uffef\012\uffef\013\uffef" +
    "\014\uffef\015\uffef\016\uffef\017\uffef\020\uffef\052\uffef\053" +
    "\uffef\054\uffef\055\uffef\056\uffef\057\uffef\060\uffef\061\uffef" +
    "\062\uffef\001\002\000\006\067\124\070\123\001\002\000" +
    "\050\003\uffec\005\uffec\010\uffec\012\uffec\013\uffec\014\uffec" +
    "\015\uffec\016\uffec\017\uffec\020\uffec\052\uffec\053\uffec\054" +
    "\uffec\055\uffec\056\uffec\057\uffec\060\uffec\061\uffec\062\uffec" +
    "\001\002\000\050\003\ufff3\005\ufff3\010\ufff3\012\ufff3\013" +
    "\ufff3\014\ufff3\015\ufff3\016\ufff3\017\ufff3\020\ufff3\052\ufff3" +
    "\053\ufff3\054\ufff3\055\ufff3\056\ufff3\057\ufff3\060\ufff3\061" +
    "\ufff3\062\ufff3\001\002\000\050\003\ufff7\005\ufff7\010\ufff7" +
    "\012\ufff7\013\ufff7\014\ufff7\015\ufff7\016\ufff7\017\ufff7\020" +
    "\ufff7\052\ufff7\053\ufff7\054\ufff7\055\ufff7\056\ufff7\057\ufff7" +
    "\060\ufff7\061\ufff7\062\ufff7\001\002\000\050\003\uffe4\005" +
    "\uffe4\010\uffe4\012\uffe4\013\uffe4\014\uffe4\015\uffe4\016\uffe4" +
    "\017\uffe4\020\uffe4\052\uffe4\053\uffe4\054\uffe4\055\uffe4\056" +
    "\uffe4\057\uffe4\060\uffe4\061\057\062\uffe4\001\002\000\050" +
    "\003\uffee\005\uffee\010\uffee\012\uffee\013\uffee\014\uffee\015" +
    "\uffee\016\uffee\017\uffee\020\uffee\052\uffee\053\uffee\054\uffee" +
    "\055\uffee\056\uffee\057\uffee\060\uffee\061\uffee\062\uffee\001" +
    "\002\000\006\003\uffd8\060\uffd8\001\002\000\050\003\ufff5" +
    "\005\ufff5\010\ufff5\012\ufff5\013\ufff5\014\ufff5\015\ufff5\016" +
    "\ufff5\017\ufff5\020\121\052\ufff5\053\ufff5\054\ufff5\055\ufff5" +
    "\056\ufff5\057\ufff5\060\ufff5\061\ufff5\062\ufff5\001\002\000" +
    "\050\003\uffdb\005\uffdb\010\uffdb\012\077\013\106\014\uffdb" +
    "\015\uffdb\016\uffdb\017\uffdb\020\uffdb\052\104\053\101\054" +
    "\103\055\102\056\100\057\105\060\uffdb\061\uffdb\062\uffdb" +
    "\001\002\000\050\003\uffe2\005\uffe2\010\uffe2\012\uffe2\013" +
    "\uffe2\014\uffe2\015\uffe2\016\uffe2\017\uffe2\020\uffe2\052\uffe2" +
    "\053\uffe2\054\uffe2\055\uffe2\056\uffe2\057\uffe2\060\uffe2\061" +
    "\uffe2\062\uffe2\001\002\000\050\003\ufffc\005\ufffc\010\ufffc" +
    "\012\ufffc\013\ufffc\014\071\015\070\016\067\017\072\020" +
    "\ufffc\052\ufffc\053\ufffc\054\ufffc\055\ufffc\056\ufffc\057\ufffc" +
    "\060\ufffc\061\ufffc\062\ufffc\001\002\000\006\003\066\060" +
    "\065\001\002\000\006\003\uffd9\060\uffd9\001\002\000\020" +
    "\004\052\013\031\063\046\067\051\070\026\071\050\074" +
    "\027\001\002\000\004\060\063\001\002\000\050\003\uffeb" +
    "\005\uffeb\010\uffeb\012\uffeb\013\uffeb\014\uffeb\015\uffeb\016" +
    "\uffeb\017\uffeb\020\uffeb\052\uffeb\053\uffeb\054\uffeb\055\uffeb" +
    "\056\uffeb\057\uffeb\060\uffeb\061\uffeb\062\uffeb\001\002\000" +
    "\050\003\ufff2\005\ufff2\010\ufff2\012\ufff2\013\ufff2\014\ufff2" +
    "\015\ufff2\016\ufff2\017\ufff2\020\ufff2\052\ufff2\053\ufff2\054" +
    "\ufff2\055\ufff2\056\ufff2\057\ufff2\060\ufff2\061\ufff2\062\ufff2" +
    "\001\002\000\020\004\052\013\031\063\046\067\051\070" +
    "\026\071\050\074\027\001\002\000\050\003\uffed\005\uffed" +
    "\010\uffed\012\uffed\013\uffed\014\uffed\015\uffed\016\uffed\017" +
    "\uffed\020\uffed\052\uffed\053\uffed\054\uffed\055\uffed\056\uffed" +
    "\057\uffed\060\uffed\061\uffed\062\uffed\001\002\000\010\003" +
    "\uffda\060\uffda\062\055\001\002\000\020\004\052\013\031" +
    "\063\046\067\051\070\026\071\050\074\027\001\002\000" +
    "\050\003\uffe5\005\uffe5\010\uffe5\012\uffe5\013\uffe5\014\uffe5" +
    "\015\uffe5\016\uffe5\017\uffe5\020\uffe5\052\uffe5\053\uffe5\054" +
    "\uffe5\055\uffe5\056\uffe5\057\uffe5\060\uffe5\061\uffe5\062\uffe5" +
    "\001\002\000\020\004\052\013\031\063\046\067\051\070" +
    "\026\071\050\074\027\001\002\000\050\003\uffe3\005\uffe3" +
    "\010\uffe3\012\uffe3\013\uffe3\014\uffe3\015\uffe3\016\uffe3\017" +
    "\uffe3\020\uffe3\052\uffe3\053\uffe3\054\uffe3\055\uffe3\056\uffe3" +
    "\057\uffe3\060\uffe3\061\uffe3\062\uffe3\001\002\000\006\005" +
    "\062\062\055\001\002\000\050\003\ufff4\005\ufff4\010\ufff4" +
    "\012\ufff4\013\ufff4\014\ufff4\015\ufff4\016\ufff4\017\ufff4\020" +
    "\ufff4\052\ufff4\053\ufff4\054\ufff4\055\ufff4\056\ufff4\057\ufff4" +
    "\060\ufff4\061\ufff4\062\ufff4\001\002\000\046\003\uffb9\007" +
    "\uffb9\024\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9" +
    "\033\uffb9\034\uffb9\035\uffb9\037\uffb9\040\uffb9\043\uffb9\050" +
    "\uffb9\051\uffb9\064\uffb9\074\uffb9\001\002\000\050\003\uffea" +
    "\005\uffea\010\uffea\012\uffea\013\uffea\014\uffea\015\uffea\016" +
    "\uffea\017\uffea\020\uffea\052\uffea\053\uffea\054\uffea\055\uffea" +
    "\056\uffea\057\uffea\060\uffea\061\uffea\062\uffea\001\002\000" +
    "\046\003\uffd2\007\uffd2\024\uffd2\025\uffd2\026\uffd2\027\uffd2" +
    "\030\uffd2\031\uffd2\033\uffd2\034\uffd2\035\uffd2\037\uffd2\040" +
    "\uffd2\043\uffd2\050\uffd2\051\uffd2\064\uffd2\074\uffd2\001\002" +
    "\000\046\003\uffc4\007\uffc4\024\uffc4\025\uffc4\026\uffc4\027" +
    "\uffc4\030\uffc4\031\uffc4\033\uffc4\034\uffc4\035\uffc4\037\uffc4" +
    "\040\uffc4\043\uffc4\050\uffc4\051\uffc4\064\uffc4\074\uffc4\001" +
    "\002\000\020\004\052\013\031\063\046\067\051\070\026" +
    "\071\050\074\027\001\002\000\020\004\052\013\031\063" +
    "\046\067\051\070\026\071\050\074\027\001\002\000\020" +
    "\004\052\013\031\063\046\067\051\070\026\071\050\074" +
    "\027\001\002\000\020\004\052\013\031\063\046\067\051" +
    "\070\026\071\050\074\027\001\002\000\050\003\ufff8\005" +
    "\ufff8\010\ufff8\012\ufff8\013\ufff8\014\ufff8\015\ufff8\016\ufff8" +
    "\017\ufff8\020\ufff8\052\ufff8\053\ufff8\054\ufff8\055\ufff8\056" +
    "\ufff8\057\ufff8\060\ufff8\061\ufff8\062\ufff8\001\002\000\050" +
    "\003\ufffb\005\ufffb\010\ufffb\012\ufffb\013\ufffb\014\ufffb\015" +
    "\ufffb\016\ufffb\017\ufffb\020\ufffb\052\ufffb\053\ufffb\054\ufffb" +
    "\055\ufffb\056\ufffb\057\ufffb\060\ufffb\061\ufffb\062\ufffb\001" +
    "\002\000\050\003\ufffa\005\ufffa\010\ufffa\012\ufffa\013\ufffa" +
    "\014\ufffa\015\ufffa\016\ufffa\017\ufffa\020\ufffa\052\ufffa\053" +
    "\ufffa\054\ufffa\055\ufffa\056\ufffa\057\ufffa\060\ufffa\061\ufffa" +
    "\062\ufffa\001\002\000\050\003\ufff9\005\ufff9\010\ufff9\012" +
    "\ufff9\013\ufff9\014\ufff9\015\ufff9\016\ufff9\017\ufff9\020\ufff9" +
    "\052\ufff9\053\ufff9\054\ufff9\055\ufff9\056\ufff9\057\ufff9\060" +
    "\ufff9\061\ufff9\062\ufff9\001\002\000\022\003\120\004\052" +
    "\013\031\063\046\067\051\070\026\071\050\074\027\001" +
    "\002\000\020\004\052\013\031\063\046\067\051\070\026" +
    "\071\050\074\027\001\002\000\020\004\052\013\031\063" +
    "\046\067\051\070\026\071\050\074\027\001\002\000\020" +
    "\004\052\013\031\063\046\067\051\070\026\071\050\074" +
    "\027\001\002\000\020\004\052\013\031\063\046\067\051" +
    "\070\026\071\050\074\027\001\002\000\020\004\052\013" +
    "\031\063\046\067\051\070\026\071\050\074\027\001\002" +
    "\000\020\004\052\013\031\063\046\067\051\070\026\071" +
    "\050\074\027\001\002\000\022\003\110\004\052\013\031" +
    "\063\046\067\051\070\026\071\050\074\027\001\002\000" +
    "\050\003\ufffe\005\ufffe\010\ufffe\012\ufffe\013\ufffe\014\071" +
    "\015\070\016\067\017\072\020\ufffe\052\ufffe\053\ufffe\054" +
    "\ufffe\055\ufffe\056\ufffe\057\ufffe\060\ufffe\061\ufffe\062\ufffe" +
    "\001\002\000\050\003\ufffd\005\ufffd\010\ufffd\012\ufffd\013" +
    "\ufffd\014\ufffd\015\ufffd\016\ufffd\017\ufffd\020\ufffd\052\ufffd" +
    "\053\ufffd\054\ufffd\055\ufffd\056\ufffd\057\ufffd\060\ufffd\061" +
    "\ufffd\062\ufffd\001\002\000\050\003\uffdc\005\uffdc\010\uffdc" +
    "\012\077\013\106\014\uffdc\015\uffdc\016\uffdc\017\uffdc\020" +
    "\uffdc\052\uffdc\053\uffdc\054\uffdc\055\uffdc\056\uffdc\057\uffdc" +
    "\060\uffdc\061\uffdc\062\uffdc\001\002\000\050\003\uffe1\005" +
    "\uffe1\010\uffe1\012\077\013\106\014\uffe1\015\uffe1\016\uffe1" +
    "\017\uffe1\020\uffe1\052\uffe1\053\uffe1\054\uffe1\055\uffe1\056" +
    "\uffe1\057\uffe1\060\uffe1\061\uffe1\062\uffe1\001\002\000\050" +
    "\003\uffdf\005\uffdf\010\uffdf\012\077\013\106\014\uffdf\015" +
    "\uffdf\016\uffdf\017\uffdf\020\uffdf\052\uffdf\053\uffdf\054\uffdf" +
    "\055\uffdf\056\uffdf\057\uffdf\060\uffdf\061\uffdf\062\uffdf\001" +
    "\002\000\050\003\uffde\005\uffde\010\uffde\012\077\013\106" +
    "\014\uffde\015\uffde\016\uffde\017\uffde\020\uffde\052\uffde\053" +
    "\uffde\054\uffde\055\uffde\056\uffde\057\uffde\060\uffde\061\uffde" +
    "\062\uffde\001\002\000\050\003\uffe0\005\uffe0\010\uffe0\012" +
    "\077\013\106\014\uffe0\015\uffe0\016\uffe0\017\uffe0\020\uffe0" +
    "\052\uffe0\053\uffe0\054\uffe0\055\uffe0\056\uffe0\057\uffe0\060" +
    "\uffe0\061\uffe0\062\uffe0\001\002\000\050\003\uffdd\005\uffdd" +
    "\010\uffdd\012\077\013\106\014\uffdd\015\uffdd\016\uffdd\017" +
    "\uffdd\020\uffdd\052\uffdd\053\uffdd\054\uffdd\055\uffdd\056\uffdd" +
    "\057\uffdd\060\uffdd\061\uffdd\062\uffdd\001\002\000\050\003" +
    "\000\005\000\010\000\012\000\013\000\014\071\015\070" +
    "\016\067\017\072\020\000\052\000\053\000\054\000\055" +
    "\000\056\000\057\000\060\000\061\000\062\000\001\002" +
    "\000\050\003\uffff\005\uffff\010\uffff\012\uffff\013\uffff\014" +
    "\uffff\015\uffff\016\uffff\017\uffff\020\uffff\052\uffff\053\uffff" +
    "\054\uffff\055\uffff\056\uffff\057\uffff\060\uffff\061\uffff\062" +
    "\uffff\001\002\000\020\004\052\013\031\063\046\067\051" +
    "\070\026\071\050\074\027\001\002\000\050\003\ufff6\005" +
    "\ufff6\010\ufff6\012\ufff6\013\ufff6\014\ufff6\015\ufff6\016\ufff6" +
    "\017\ufff6\020\ufff6\052\ufff6\053\ufff6\054\ufff6\055\ufff6\056" +
    "\ufff6\057\ufff6\060\ufff6\061\ufff6\062\ufff6\001\002\000\050" +
    "\003\uffe8\005\uffe8\010\uffe8\012\uffe8\013\uffe8\014\uffe8\015" +
    "\uffe8\016\uffe8\017\uffe8\020\uffe8\052\uffe8\053\uffe8\054\uffe8" +
    "\055\uffe8\056\uffe8\057\uffe8\060\uffe8\061\uffe8\062\uffe8\001" +
    "\002\000\050\003\uffe9\005\uffe9\010\uffe9\012\uffe9\013\uffe9" +
    "\014\uffe9\015\uffe9\016\uffe9\017\uffe9\020\uffe9\052\uffe9\053" +
    "\uffe9\054\uffe9\055\uffe9\056\uffe9\057\uffe9\060\uffe9\061\uffe9" +
    "\062\uffe9\001\002\000\016\005\141\067\142\070\137\072" +
    "\135\073\140\074\133\001\002\000\050\003\uffe7\005\uffe7" +
    "\010\uffe7\012\uffe7\013\uffe7\014\uffe7\015\uffe7\016\uffe7\017" +
    "\uffe7\020\uffe7\052\uffe7\053\uffe7\054\uffe7\055\uffe7\056\uffe7" +
    "\057\uffe7\060\uffe7\061\uffe7\062\uffe7\001\002\000\050\003" +
    "\uffe6\005\uffe6\010\uffe6\012\uffe6\013\uffe6\014\uffe6\015\uffe6" +
    "\016\uffe6\017\uffe6\020\uffe6\052\uffe6\053\uffe6\054\uffe6\055" +
    "\uffe6\056\uffe6\057\uffe6\060\uffe6\061\uffe6\062\uffe6\001\002" +
    "\000\020\004\052\013\031\063\046\067\051\070\026\071" +
    "\050\074\027\001\002\000\010\010\132\012\077\013\106" +
    "\001\002\000\052\003\uff87\005\uff87\010\uff87\012\uff87\013" +
    "\uff87\014\uff87\015\uff87\016\uff87\017\uff87\020\uff87\036\uff87" +
    "\052\uff87\053\uff87\054\uff87\055\uff87\056\uff87\057\uff87\060" +
    "\uff87\061\uff87\062\uff87\001\002\000\010\005\uff41\011\130" +
    "\036\uff41\001\002\000\006\005\146\036\145\001\002\000" +
    "\002\001\002\000\006\005\uff40\036\uff40\001\002\000\006" +
    "\005\uff42\036\uff42\001\002\000\002\001\002\000\050\003" +
    "\uff45\005\uff45\010\uff45\012\uff45\013\uff45\014\uff45\015\uff45" +
    "\016\uff45\017\uff45\020\uff45\052\uff45\053\uff45\054\uff45\055" +
    "\uff45\056\uff45\057\uff45\060\uff45\061\uff45\062\uff45\001\002" +
    "\000\006\005\uff43\036\uff43\001\002\000\006\005\uff3f\036" +
    "\uff3f\001\002\000\006\005\uff3e\036\uff3e\001\002\000\014" +
    "\067\154\070\152\072\150\073\153\074\147\001\002\000" +
    "\050\003\uff44\005\uff44\010\uff44\012\uff44\013\uff44\014\uff44" +
    "\015\uff44\016\uff44\017\uff44\020\uff44\052\uff44\053\uff44\054" +
    "\uff44\055\uff44\056\uff44\057\uff44\060\uff44\061\uff44\062\uff44" +
    "\001\002\000\010\005\uff3b\011\130\036\uff3b\001\002\000" +
    "\006\005\uff38\036\uff38\001\002\000\006\005\uff3a\036\uff3a" +
    "\001\002\000\006\005\uff3c\036\uff3c\001\002\000\006\005" +
    "\uff39\036\uff39\001\002\000\006\005\uff3d\036\uff3d\001\002" +
    "\000\010\003\162\023\160\060\161\001\002\000\004\060" +
    "\157\001\002\000\046\003\uffc9\007\uffc9\024\uffc9\025\uffc9" +
    "\026\uffc9\027\uffc9\030\uffc9\031\uffc9\033\uffc9\034\uffc9\035" +
    "\uffc9\037\uffc9\040\uffc9\043\uffc9\050\uffc9\051\uffc9\064\uffc9" +
    "\074\uffc9\001\002\000\026\003\164\004\052\013\031\063" +
    "\046\067\051\070\026\071\050\072\045\073\037\074\027" +
    "\001\002\000\046\003\uffd5\007\uffd5\024\uffd5\025\uffd5\026" +
    "\uffd5\027\uffd5\030\uffd5\031\uffd5\033\uffd5\034\uffd5\035\uffd5" +
    "\037\uffd5\040\uffd5\043\uffd5\050\uffd5\051\uffd5\064\uffd5\074" +
    "\uffd5\001\002\000\046\003\uffc5\007\uffc5\024\uffc5\025\uffc5" +
    "\026\uffc5\027\uffc5\030\uffc5\031\uffc5\033\uffc5\034\uffc5\035" +
    "\uffc5\037\uffc5\040\uffc5\043\uffc5\050\uffc5\051\uffc5\064\uffc5" +
    "\074\uffc5\001\002\000\006\003\167\060\166\001\002\000" +
    "\004\060\165\001\002\000\046\003\uffb7\007\uffb7\024\uffb7" +
    "\025\uffb7\026\uffb7\027\uffb7\030\uffb7\031\uffb7\033\uffb7\034" +
    "\uffb7\035\uffb7\037\uffb7\040\uffb7\043\uffb7\050\uffb7\051\uffb7" +
    "\064\uffb7\074\uffb7\001\002\000\046\003\uffd0\007\uffd0\024" +
    "\uffd0\025\uffd0\026\uffd0\027\uffd0\030\uffd0\031\uffd0\033\uffd0" +
    "\034\uffd0\035\uffd0\037\uffd0\040\uffd0\043\uffd0\050\uffd0\051" +
    "\uffd0\064\uffd0\074\uffd0\001\002\000\046\003\uffc2\007\uffc2" +
    "\024\uffc2\025\uffc2\026\uffc2\027\uffc2\030\uffc2\031\uffc2\033" +
    "\uffc2\034\uffc2\035\uffc2\037\uffc2\040\uffc2\043\uffc2\050\uffc2" +
    "\051\uffc2\064\uffc2\074\uffc2\001\002\000\006\023\173\060" +
    "\174\001\002\000\004\060\172\001\002\000\046\003\uffc8" +
    "\007\uffc8\024\uffc8\025\uffc8\026\uffc8\027\uffc8\030\uffc8\031" +
    "\uffc8\033\uffc8\034\uffc8\035\uffc8\037\uffc8\040\uffc8\043\uffc8" +
    "\050\uffc8\051\uffc8\064\uffc8\074\uffc8\001\002\000\026\003" +
    "\176\004\052\013\031\063\046\067\051\070\026\071\050" +
    "\072\045\073\037\074\027\001\002\000\046\003\uffd4\007" +
    "\uffd4\024\uffd4\025\uffd4\026\uffd4\027\uffd4\030\uffd4\031\uffd4" +
    "\033\uffd4\034\uffd4\035\uffd4\037\uffd4\040\uffd4\043\uffd4\050" +
    "\uffd4\051\uffd4\064\uffd4\074\uffd4\001\002\000\006\003\201" +
    "\060\200\001\002\000\004\060\177\001\002\000\046\003" +
    "\uffb6\007\uffb6\024\uffb6\025\uffb6\026\uffb6\027\uffb6\030\uffb6" +
    "\031\uffb6\033\uffb6\034\uffb6\035\uffb6\037\uffb6\040\uffb6\043" +
    "\uffb6\050\uffb6\051\uffb6\064\uffb6\074\uffb6\001\002\000\046" +
    "\003\uffcf\007\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\030" +
    "\uffcf\031\uffcf\033\uffcf\034\uffcf\035\uffcf\037\uffcf\040\uffcf" +
    "\043\uffcf\050\uffcf\051\uffcf\064\uffcf\074\uffcf\001\002\000" +
    "\046\003\uffc1\007\uffc1\024\uffc1\025\uffc1\026\uffc1\027\uffc1" +
    "\030\uffc1\031\uffc1\033\uffc1\034\uffc1\035\uffc1\037\uffc1\040" +
    "\uffc1\043\uffc1\050\uffc1\051\uffc1\064\uffc1\074\uffc1\001\002" +
    "\000\004\060\214\001\002\000\010\003\206\023\204\060" +
    "\205\001\002\000\026\003\210\004\052\013\031\063\046" +
    "\067\051\070\026\071\050\072\045\073\037\074\027\001" +
    "\002\000\046\003\uffd6\007\uffd6\024\uffd6\025\uffd6\026\uffd6" +
    "\027\uffd6\030\uffd6\031\uffd6\033\uffd6\034\uffd6\035\uffd6\037" +
    "\uffd6\040\uffd6\043\uffd6\050\uffd6\051\uffd6\064\uffd6\074\uffd6" +
    "\001\002\000\046\003\uffc6\007\uffc6\024\uffc6\025\uffc6\026" +
    "\uffc6\027\uffc6\030\uffc6\031\uffc6\033\uffc6\034\uffc6\035\uffc6" +
    "\037\uffc6\040\uffc6\043\uffc6\050\uffc6\051\uffc6\064\uffc6\074" +
    "\uffc6\001\002\000\006\003\213\060\212\001\002\000\004" +
    "\060\211\001\002\000\046\003\uffb8\007\uffb8\024\uffb8\025" +
    "\uffb8\026\uffb8\027\uffb8\030\uffb8\031\uffb8\033\uffb8\034\uffb8" +
    "\035\uffb8\037\uffb8\040\uffb8\043\uffb8\050\uffb8\051\uffb8\064" +
    "\uffb8\074\uffb8\001\002\000\046\003\uffd1\007\uffd1\024\uffd1" +
    "\025\uffd1\026\uffd1\027\uffd1\030\uffd1\031\uffd1\033\uffd1\034" +
    "\uffd1\035\uffd1\037\uffd1\040\uffd1\043\uffd1\050\uffd1\051\uffd1" +
    "\064\uffd1\074\uffd1\001\002\000\046\003\uffc3\007\uffc3\024" +
    "\uffc3\025\uffc3\026\uffc3\027\uffc3\030\uffc3\031\uffc3\033\uffc3" +
    "\034\uffc3\035\uffc3\037\uffc3\040\uffc3\043\uffc3\050\uffc3\051" +
    "\uffc3\064\uffc3\074\uffc3\001\002\000\046\003\uffca\007\uffca" +
    "\024\uffca\025\uffca\026\uffca\027\uffca\030\uffca\031\uffca\033" +
    "\uffca\034\uffca\035\uffca\037\uffca\040\uffca\043\uffca\050\uffca" +
    "\051\uffca\064\uffca\074\uffca\001\002\000\004\060\226\001" +
    "\002\000\006\023\217\060\220\001\002\000\026\003\222" +
    "\004\052\013\031\063\046\067\051\070\026\071\050\072" +
    "\045\073\037\074\027\001\002\000\046\003\uffd3\007\uffd3" +
    "\024\uffd3\025\uffd3\026\uffd3\027\uffd3\030\uffd3\031\uffd3\033" +
    "\uffd3\034\uffd3\035\uffd3\037\uffd3\040\uffd3\043\uffd3\050\uffd3" +
    "\051\uffd3\064\uffd3\074\uffd3\001\002\000\006\003\225\060" +
    "\224\001\002\000\004\060\223\001\002\000\046\003\uffb5" +
    "\007\uffb5\024\uffb5\025\uffb5\026\uffb5\027\uffb5\030\uffb5\031" +
    "\uffb5\033\uffb5\034\uffb5\035\uffb5\037\uffb5\040\uffb5\043\uffb5" +
    "\050\uffb5\051\uffb5\064\uffb5\074\uffb5\001\002\000\046\003" +
    "\uffce\007\uffce\024\uffce\025\uffce\026\uffce\027\uffce\030\uffce" +
    "\031\uffce\033\uffce\034\uffce\035\uffce\037\uffce\040\uffce\043" +
    "\uffce\050\uffce\051\uffce\064\uffce\074\uffce\001\002\000\046" +
    "\003\uffc0\007\uffc0\024\uffc0\025\uffc0\026\uffc0\027\uffc0\030" +
    "\uffc0\031\uffc0\033\uffc0\034\uffc0\035\uffc0\037\uffc0\040\uffc0" +
    "\043\uffc0\050\uffc0\051\uffc0\064\uffc0\074\uffc0\001\002\000" +
    "\046\003\uffc7\007\uffc7\024\uffc7\025\uffc7\026\uffc7\027\uffc7" +
    "\030\uffc7\031\uffc7\033\uffc7\034\uffc7\035\uffc7\037\uffc7\040" +
    "\uffc7\043\uffc7\050\uffc7\051\uffc7\064\uffc7\074\uffc7\001\002" +
    "\000\006\023\230\060\231\001\002\000\024\004\052\013" +
    "\031\063\046\067\051\070\026\071\050\072\045\073\037" +
    "\074\027\001\002\000\046\003\uffcc\007\uffcc\024\uffcc\025" +
    "\uffcc\026\uffcc\027\uffcc\030\uffcc\031\uffcc\033\uffcc\034\uffcc" +
    "\035\uffcc\037\uffcc\040\uffcc\043\uffcc\050\uffcc\051\uffcc\064" +
    "\uffcc\074\uffcc\001\002\000\004\060\233\001\002\000\046" +
    "\003\uffbf\007\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf\030" +
    "\uffbf\031\uffbf\033\uffbf\034\uffbf\035\uffbf\037\uffbf\040\uffbf" +
    "\043\uffbf\050\uffbf\051\uffbf\064\uffbf\074\uffbf\001\002\000" +
    "\004\074\uff59\001\002\000\004\074\uff58\001\002\000\004" +
    "\006\267\001\002\000\004\074\uff5b\001\002\000\004\074" +
    "\u020d\001\002\000\004\032\u020a\001\002\000\016\024\uff23" +
    "\025\uff23\026\uff23\027\uff23\030\uff23\031\uff23\001\002\000" +
    "\004\074\u0209\001\002\000\004\074\uff5a\001\002\000\004" +
    "\074\uff5c\001\002\000\004\074\u0208\001\002\000\004\002" +
    "\uff22\001\002\000\004\074\u0207\001\002\000\004\004\254" +
    "\001\002\000\004\074\253\001\002\000\004\004\uff57\001" +
    "\002\000\020\003\265\005\262\024\263\025\257\026\264" +
    "\027\255\030\256\001\002\000\004\074\u0206\001\002\000" +
    "\004\074\u0205\001\002\000\004\074\u0204\001\002\000\006" +
    "\005\uff4e\036\u0200\001\002\000\004\005\u01fe\001\002\000" +
    "\004\006\267\001\002\000\004\074\u01fc\001\002\000\004" +
    "\074\u01fb\001\002\000\004\005\266\001\002\000\004\006" +
    "\267\001\002\000\026\003\311\007\277\033\306\034\302" +
    "\035\314\037\325\043\310\050\300\064\276\074\275\001" +
    "\002\000\016\024\uff50\025\uff50\026\uff50\027\uff50\030\uff50" +
    "\031\uff50\001\002\000\032\003\uff32\007\uff32\033\uff32\034" +
    "\uff32\035\uff32\037\uff32\040\uff32\043\uff32\050\uff32\051\uff32" +
    "\064\uff32\074\uff32\001\002\000\026\003\uff34\007\uff34\033" +
    "\uff34\034\uff34\035\uff34\037\uff34\043\uff34\050\uff34\064\uff34" +
    "\074\uff34\001\002\000\032\003\uff2f\007\uff2f\033\uff2f\034" +
    "\uff2f\035\uff2f\037\uff2f\040\uff2f\043\uff2f\050\uff2f\051\uff2f" +
    "\064\uff2f\074\uff2f\001\002\000\006\003\u01eb\074\u01ea\001" +
    "\002\000\006\011\u01dc\023\u01db\001\002\000\004\065\u01cf" +
    "\001\002\000\020\002\uff36\024\uff36\025\uff36\026\uff36\027" +
    "\uff36\030\uff36\031\uff36\001\002\000\022\004\052\013\031" +
    "\060\u01cc\063\046\067\051\070\026\071\050\074\027\001" +
    "\002\000\010\004\u01ad\042\u01ab\066\u01ae\001\002\000\006" +
    "\003\u01a4\074\u01a5\001\002\000\020\004\052\013\031\063" +
    "\046\067\051\070\026\071\050\074\027\001\002\000\004" +
    "\006\u019d\001\002\000\032\003\uff2d\007\uff2d\033\uff2d\034" +
    "\uff2d\035\uff2d\037\uff2d\040\uff2d\043\uff2d\050\uff2d\051\uff2d" +
    "\064\uff2d\074\uff2d\001\002\000\016\003\u012d\024\u012f\025" +
    "\015\026\017\027\u012e\030\014\001\002\000\032\003\uff31" +
    "\007\uff31\033\uff31\034\uff31\035\uff31\037\uff31\040\uff31\043" +
    "\uff31\050\uff31\051\uff31\064\uff31\074\uff31\001\002\000\006" +
    "\003\uff62\074\uff62\001\002\000\024\007\u012c\023\337\024" +
    "\346\025\341\026\345\027\343\030\342\034\344\060\340" +
    "\001\002\000\032\003\uff2a\007\uff2a\033\uff2a\034\uff2a\035" +
    "\uff2a\037\uff2a\040\uff2a\043\uff2a\050\uff2a\051\uff2a\064\uff2a" +
    "\074\uff2a\001\002\000\026\003\u011f\033\306\034\302\035" +
    "\314\037\325\043\310\050\300\051\330\064\276\074\275" +
    "\001\002\000\020\003\u0113\067\u0117\070\u0115\071\u0111\072" +
    "\u0114\073\u0116\074\u0112\001\002\000\032\003\uff30\007\uff30" +
    "\033\uff30\034\uff30\035\uff30\037\uff30\040\uff30\043\uff30\050" +
    "\uff30\051\uff30\064\uff30\074\uff30\001\002\000\026\003\332" +
    "\007\u0110\033\306\034\302\035\314\037\325\043\310\050" +
    "\300\064\276\074\275\001\002\000\032\003\uff2b\007\uff2b" +
    "\033\uff2b\034\uff2b\035\uff2b\037\uff2b\040\uff2b\043\uff2b\050" +
    "\uff2b\051\uff2b\064\uff2b\074\uff2b\001\002\000\032\003\uff2c" +
    "\007\uff2c\033\uff2c\034\uff2c\035\uff2c\037\uff2c\040\uff2c\043" +
    "\uff2c\050\uff2c\051\uff2c\064\uff2c\074\uff2c\001\002\000\026" +
    "\003\uff6a\033\uff6a\034\uff6a\035\uff6a\037\uff6a\043\uff6a\050" +
    "\uff6a\051\uff6a\064\uff6a\074\uff6a\001\002\000\032\003\uff29" +
    "\007\uff29\033\uff29\034\uff29\035\uff29\037\uff29\040\uff29\043" +
    "\uff29\050\uff29\051\uff29\064\uff29\074\uff29\001\002\000\004" +
    "\006\326\001\002\000\032\003\uff2e\007\uff2e\033\uff2e\034" +
    "\uff2e\035\uff2e\037\uff2e\040\uff2e\043\uff2e\050\uff2e\051\uff2e" +
    "\064\uff2e\074\uff2e\001\002\000\026\003\uff6b\033\uff6b\034" +
    "\uff6b\035\uff6b\037\uff6b\043\uff6b\050\uff6b\051\uff6b\064\uff6b" +
    "\074\uff6b\001\002\000\026\003\332\033\306\034\302\035" +
    "\314\037\325\043\310\050\300\051\330\064\276\074\275" +
    "\001\002\000\032\003\uff67\007\uff67\033\uff67\034\uff67\035" +
    "\uff67\037\uff67\040\uff67\043\uff67\050\uff67\051\uff67\064\uff67" +
    "\074\uff67\001\002\000\004\060\u010e\001\002\000\032\003" +
    "\uff66\007\uff66\033\uff66\034\uff66\035\uff66\037\uff66\040\uff66" +
    "\043\uff66\050\uff66\051\uff66\064\uff66\074\uff66\001\002\000" +
    "\022\023\337\024\346\025\341\026\345\027\343\030\342" +
    "\034\344\060\340\001\002\000\030\003\332\007\335\033" +
    "\306\034\302\035\314\037\325\043\310\050\300\051\330" +
    "\064\276\074\275\001\002\000\032\003\uff65\007\uff65\033" +
    "\uff65\034\uff65\035\uff65\037\uff65\040\uff65\043\uff65\050\uff65" +
    "\051\uff65\064\uff65\074\uff65\001\002\000\010\004\uff79\042" +
    "\uff79\066\uff79\001\002\000\032\003\uff64\007\uff64\033\uff64" +
    "\034\uff64\035\uff64\037\uff64\040\uff64\043\uff64\050\uff64\051" +
    "\uff64\064\uff64\074\uff64\001\002\000\024\004\052\013\031" +
    "\063\046\067\051\070\026\071\050\072\045\073\037\074" +
    "\027\001\002\000\046\003\uffcd\007\uffcd\024\uffcd\025\uffcd" +
    "\026\uffcd\027\uffcd\030\uffcd\031\uffcd\033\uffcd\034\uffcd\035" +
    "\uffcd\037\uffcd\040\uffcd\043\uffcd\050\uffcd\051\uffcd\064\uffcd" +
    "\074\uffcd\001\002\000\004\074\u010a\001\002\000\004\074" +
    "\u0108\001\002\000\004\074\375\001\002\000\004\074\373" +
    "\001\002\000\004\074\371\001\002\000\004\074\347\001" +
    "\002\000\006\011\351\060\350\001\002\000\046\003\uffbe" +
    "\007\uffbe\024\uffbe\025\uffbe\026\uffbe\027\uffbe\030\uffbe\031" +
    "\uffbe\033\uffbe\034\uffbe\035\uffbe\037\uffbe\040\uffbe\043\uffbe" +
    "\050\uffbe\051\uffbe\064\uffbe\074\uffbe\001\002\000\020\004" +
    "\052\013\031\063\046\067\051\070\026\071\050\074\027" +
    "\001\002\000\010\010\353\012\077\013\106\001\002\000" +
    "\006\023\354\060\355\001\002\000\004\006\356\001\002" +
    "\000\032\003\uffae\007\uffae\033\uffae\034\uffae\035\uffae\037" +
    "\uffae\040\uffae\043\uffae\050\uffae\051\uffae\064\uffae\074\uffae" +
    "\001\002\000\010\067\362\072\360\074\357\001\002\000" +
    "\006\007\uff8d\036\uff8d\001\002\000\006\007\uff8e\036\uff8e" +
    "\001\002\000\006\007\364\036\363\001\002\000\006\007" +
    "\uff8f\036\uff8f\001\002\000\010\067\370\072\367\074\366" +
    "\001\002\000\004\060\365\001\002\000\032\003\uff9e\007" +
    "\uff9e\033\uff9e\034\uff9e\035\uff9e\037\uff9e\040\uff9e\043\uff9e" +
    "\050\uff9e\051\uff9e\064\uff9e\074\uff9e\001\002\000\006\007" +
    "\uff8a\036\uff8a\001\002\000\006\007\uff8b\036\uff8b\001\002" +
    "\000\006\007\uff8c\036\uff8c\001\002\000\004\060\372\001" +
    "\002\000\046\003\uffbc\007\uffbc\024\uffbc\025\uffbc\026\uffbc" +
    "\027\uffbc\030\uffbc\031\uffbc\033\uffbc\034\uffbc\035\uffbc\037" +
    "\uffbc\040\uffbc\043\uffbc\050\uffbc\051\uffbc\064\uffbc\074\uffbc" +
    "\001\002\000\004\060\374\001\002\000\032\003\uff84\007" +
    "\uff84\033\uff84\034\uff84\035\uff84\037\uff84\040\uff84\043\uff84" +
    "\050\uff84\051\uff84\064\uff84\074\uff84\001\002\000\006\011" +
    "\377\060\376\001\002\000\046\003\uffbb\007\uffbb\024\uffbb" +
    "\025\uffbb\026\uffbb\027\uffbb\030\uffbb\031\uffbb\033\uffbb\034" +
    "\uffbb\035\uffbb\037\uffbb\040\uffbb\043\uffbb\050\uffbb\051\uffbb" +
    "\064\uffbb\074\uffbb\001\002\000\020\004\052\013\031\063" +
    "\046\067\051\070\026\071\050\074\027\001\002\000\010" +
    "\010\u0101\012\077\013\106\001\002\000\006\023\u0102\060" +
    "\u0103\001\002\000\004\006\u0104\001\002\000\032\003\uffa6" +
    "\007\uffa6\033\uffa6\034\uffa6\035\uffa6\037\uffa6\040\uffa6\043" +
    "\uffa6\050\uffa6\051\uffa6\064\uffa6\074\uffa6\001\002\000\010" +
    "\067\362\072\360\074\357\001\002\000\006\007\u0106\036" +
    "\363\001\002\000\004\060\u0107\001\002\000\032\003\uff95" +
    "\007\uff95\033\uff95\034\uff95\035\uff95\037\uff95\040\uff95\043" +
    "\uff95\050\uff95\051\uff95\064\uff95\074\uff95\001\002\000\004" +
    "\060\u0109\001\002\000\046\003\uffba\007\uffba\024\uffba\025" +
    "\uffba\026\uffba\027\uffba\030\uffba\031\uffba\033\uffba\034\uffba" +
    "\035\uffba\037\uffba\040\uffba\043\uffba\050\uffba\051\uffba\064" +
    "\uffba\074\uffba\001\002\000\004\060\u010b\001\002\000\046" +
    "\003\uffbd\007\uffbd\024\uffbd\025\uffbd\026\uffbd\027\uffbd\030" +
    "\uffbd\031\uffbd\033\uffbd\034\uffbd\035\uffbd\037\uffbd\040\uffbd" +
    "\043\uffbd\050\uffbd\051\uffbd\064\uffbd\074\uffbd\001\002\000" +
    "\004\060\u010d\001\002\000\034\003\uffb2\007\uffb2\033\uffb2" +
    "\034\uffb2\035\uffb2\037\uffb2\040\uffb2\043\uffb2\044\uffb2\050" +
    "\uffb2\051\uffb2\064\uffb2\074\uffb2\001\002\000\032\003\uff63" +
    "\007\uff63\033\uff63\034\uff63\035\uff63\037\uff63\040\uff63\043" +
    "\uff63\050\uff63\051\uff63\064\uff63\074\uff63\001\002\000\026" +
    "\003\uff33\007\uff33\033\uff33\034\uff33\035\uff33\037\uff33\043" +
    "\uff33\050\uff33\064\uff33\074\uff33\001\002\000\020\002\uff37" +
    "\024\uff37\025\uff37\026\uff37\027\uff37\030\uff37\031\uff37\001" +
    "\002\000\004\060\u011e\001\002\000\004\060\u011d\001\002" +
    "\000\004\060\u011c\001\002\000\004\060\u011b\001\002\000" +
    "\004\060\u011a\001\002\000\004\060\u0119\001\002\000\004" +
    "\060\u0118\001\002\000\032\003\uff81\007\uff81\033\uff81\034" +
    "\uff81\035\uff81\037\uff81\040\uff81\043\uff81\050\uff81\051\uff81" +
    "\064\uff81\074\uff81\001\002\000\032\003\uff7d\007\uff7d\033" +
    "\uff7d\034\uff7d\035\uff7d\037\uff7d\040\uff7d\043\uff7d\050\uff7d" +
    "\051\uff7d\064\uff7d\074\uff7d\001\002\000\032\003\uff80\007" +
    "\uff80\033\uff80\034\uff80\035\uff80\037\uff80\040\uff80\043\uff80" +
    "\050\uff80\051\uff80\064\uff80\074\uff80\001\002\000\032\003" +
    "\uff7e\007\uff7e\033\uff7e\034\uff7e\035\uff7e\037\uff7e\040\uff7e" +
    "\043\uff7e\050\uff7e\051\uff7e\064\uff7e\074\uff7e\001\002\000" +
    "\032\003\uff7c\007\uff7c\033\uff7c\034\uff7c\035\uff7c\037\uff7c" +
    "\040\uff7c\043\uff7c\050\uff7c\051\uff7c\064\uff7c\074\uff7c\001" +
    "\002\000\032\003\uff82\007\uff82\033\uff82\034\uff82\035\uff82" +
    "\037\uff82\040\uff82\043\uff82\050\uff82\051\uff82\064\uff82\074" +
    "\uff82\001\002\000\032\003\uff7f\007\uff7f\033\uff7f\034\uff7f" +
    "\035\uff7f\037\uff7f\040\uff7f\043\uff7f\050\uff7f\051\uff7f\064" +
    "\uff7f\074\uff7f\001\002\000\024\023\337\024\346\025\341" +
    "\026\345\027\343\030\342\034\344\040\u0128\060\340\001" +
    "\002\000\030\003\332\033\306\034\302\035\314\037\325" +
    "\040\u0121\043\310\050\300\051\330\064\276\074\275\001" +
    "\002\000\004\041\u0122\001\002\000\020\004\052\013\031" +
    "\063\046\067\051\070\026\071\050\074\027\001\002\000" +
    "\006\060\u0124\062\055\001\002\000\004\042\u0125\001\002" +
    "\000\004\037\u0126\001\002\000\004\060\u0127\001\002\000" +
    "\032\003\uff69\007\uff69\033\uff69\034\uff69\035\uff69\037\uff69" +
    "\040\uff69\043\uff69\050\uff69\051\uff69\064\uff69\074\uff69\001" +
    "\002\000\004\041\u0129\001\002\000\004\037\u012a\001\002" +
    "\000\004\060\u012b\001\002\000\032\003\uff68\007\uff68\033" +
    "\uff68\034\uff68\035\uff68\037\uff68\040\uff68\043\uff68\050\uff68" +
    "\051\uff68\064\uff68\074\uff68\001\002\000\020\002\uff35\024" +
    "\uff35\025\uff35\026\uff35\027\uff35\030\uff35\031\uff35\001\002" +
    "\000\004\074\u0193\001\002\000\006\003\u0163\074\u0162\001" +
    "\002\000\006\003\u0130\074\u0131\001\002\000\006\011\u0159" +
    "\060\023\001\002\000\012\003\u0132\011\u0133\023\024\060" +
    "\025\001\002\000\022\004\052\013\031\060\u0150\063\046" +
    "\067\051\070\026\071\050\074\027\001\002\000\022\003" +
    "\u0135\004\052\013\031\063\046\067\051\070\026\071\050" +
    "\074\027\001\002\000\012\003\u013e\010\u013d\012\077\013" +
    "\106\001\002\000\004\010\u0136\001\002\000\006\023\u0137" +
    "\060\u0138\001\002\000\004\006\u0139\001\002\000\032\003" +
    "\uffab\007\uffab\033\uffab\034\uffab\035\uffab\037\uffab\040\uffab" +
    "\043\uffab\050\uffab\051\uffab\064\uffab\074\uffab\001\002\000" +
    "\010\067\362\072\360\074\357\001\002\000\006\007\u013b" +
    "\036\363\001\002\000\004\060\u013c\001\002\000\032\003" +
    "\uff9b\007\uff9b\033\uff9b\034\uff9b\035\uff9b\037\uff9b\040\uff9b" +
    "\043\uff9b\050\uff9b\051\uff9b\064\uff9b\074\uff9b\001\002\000" +
    "\010\003\u0147\023\u0145\060\u0146\001\002\000\006\023\u013f" +
    "\060\u0140\001\002\000\004\006\u0141\001\002\000\032\003" +
    "\uffaa\007\uffaa\033\uffaa\034\uffaa\035\uffaa\037\uffaa\040\uffaa" +
    "\043\uffaa\050\uffaa\051\uffaa\064\uffaa\074\uffaa\001\002\000" +
    "\010\067\362\072\360\074\357\001\002\000\006\007\u0143" +
    "\036\363\001\002\000\004\060\u0144\001\002\000\032\003" +
    "\uff9a\007\uff9a\033\uff9a\034\uff9a\035\uff9a\037\uff9a\040\uff9a" +
    "\043\uff9a\050\uff9a\051\uff9a\064\uff9a\074\uff9a\001\002\000" +
    "\004\006\u0148\001\002\000\032\003\uffb0\007\uffb0\033\uffb0" +
    "\034\uffb0\035\uffb0\037\uffb0\040\uffb0\043\uffb0\050\uffb0\051" +
    "\uffb0\064\uffb0\074\uffb0\001\002\000\032\003\uffa8\007\uffa8" +
    "\033\uffa8\034\uffa8\035\uffa8\037\uffa8\040\uffa8\043\uffa8\050" +
    "\uffa8\051\uffa8\064\uffa8\074\uffa8\001\002\000\012\003\u0149" +
    "\067\362\072\360\074\357\001\002\000\004\007\u014e\001" +
    "\002\000\006\007\u014b\036\363\001\002\000\006\003\u014d" +
    "\060\u014c\001\002\000\032\003\uff9f\007\uff9f\033\uff9f\034" +
    "\uff9f\035\uff9f\037\uff9f\040\uff9f\043\uff9f\050\uff9f\051\uff9f" +
    "\064\uff9f\074\uff9f\001\002\000\032\003\uff98\007\uff98\033" +
    "\uff98\034\uff98\035\uff98\037\uff98\040\uff98\043\uff98\050\uff98" +
    "\051\uff98\064\uff98\074\uff98\001\002\000\004\060\u014f\001" +
    "\002\000\032\003\uff97\007\uff97\033\uff97\034\uff97\035\uff97" +
    "\037\uff97\040\uff97\043\uff97\050\uff97\051\uff97\064\uff97\074" +
    "\uff97\001\002\000\032\003\uffaf\007\uffaf\033\uffaf\034\uffaf" +
    "\035\uffaf\037\uffaf\040\uffaf\043\uffaf\050\uffaf\051\uffaf\064" +
    "\uffaf\074\uffaf\001\002\000\010\010\u0152\012\077\013\106" +
    "\001\002\000\006\023\u0153\060\u0154\001\002\000\004\006" +
    "\u0155\001\002\000\032\003\uffa9\007\uffa9\033\uffa9\034\uffa9" +
    "\035\uffa9\037\uffa9\040\uffa9\043\uffa9\050\uffa9\051\uffa9\064" +
    "\uffa9\074\uffa9\001\002\000\010\067\362\072\360\074\357" +
    "\001\002\000\006\007\u0157\036\363\001\002\000\004\060" +
    "\u0158\001\002\000\032\003\uff99\007\uff99\033\uff99\034\uff99" +
    "\035\uff99\037\uff99\040\uff99\043\uff99\050\uff99\051\uff99\064" +
    "\uff99\074\uff99\001\002\000\020\004\052\013\031\063\046" +
    "\067\051\070\026\071\050\074\027\001\002\000\010\010" +
    "\u015b\012\077\013\106\001\002\000\006\023\u015c\060\u015d" +
    "\001\002\000\004\006\u015e\001\002\000\032\003\uffac\007" +
    "\uffac\033\uffac\034\uffac\035\uffac\037\uffac\040\uffac\043\uffac" +
    "\050\uffac\051\uffac\064\uffac\074\uffac\001\002\000\010\067" +
    "\362\072\360\074\357\001\002\000\006\007\u0160\036\363" +
    "\001\002\000\004\060\u0161\001\002\000\032\003\uff9c\007" +
    "\uff9c\033\uff9c\034\uff9c\035\uff9c\037\uff9c\040\uff9c\043\uff9c" +
    "\050\uff9c\051\uff9c\064\uff9c\074\uff9c\001\002\000\012\003" +
    "\u016d\011\u016e\023\173\060\174\001\002\000\006\011\u0164" +
    "\060\172\001\002\000\020\004\052\013\031\063\046\067" +
    "\051\070\026\071\050\074\027\001\002\000\010\010\u0166" +
    "\012\077\013\106\001\002\000\006\023\u0167\060\u0168\001" +
    "\002\000\004\006\u0169\001\002\000\032\003\uffa5\007\uffa5" +
    "\033\uffa5\034\uffa5\035\uffa5\037\uffa5\040\uffa5\043\uffa5\050" +
    "\uffa5\051\uffa5\064\uffa5\074\uffa5\001\002\000\010\067\362" +
    "\072\360\074\357\001\002\000\006\007\u016b\036\363\001" +
    "\002\000\004\060\u016c\001\002\000\032\003\uff94\007\uff94" +
    "\033\uff94\034\uff94\035\uff94\037\uff94\040\uff94\043\uff94\050" +
    "\uff94\051\uff94\064\uff94\074\uff94\001\002\000\022\004\052" +
    "\013\031\060\u018a\063\046\067\051\070\026\071\050\074" +
    "\027\001\002\000\022\003\u0170\004\052\013\031\063\046" +
    "\067\051\070\026\071\050\074\027\001\002\000\012\003" +
    "\u0179\010\u0178\012\077\013\106\001\002\000\004\010\u0171" +
    "\001\002\000\006\023\u0172\060\u0173\001\002\000\004\006" +
    "\u0174\001\002\000\032\003\uffa4\007\uffa4\033\uffa4\034\uffa4" +
    "\035\uffa4\037\uffa4\040\uffa4\043\uffa4\050\uffa4\051\uffa4\064" +
    "\uffa4\074\uffa4\001\002\000\010\067\362\072\360\074\357" +
    "\001\002\000\006\007\u0176\036\363\001\002\000\004\060" +
    "\u0177\001\002\000\032\003\uff93\007\uff93\033\uff93\034\uff93" +
    "\035\uff93\037\uff93\040\uff93\043\uff93\050\uff93\051\uff93\064" +
    "\uff93\074\uff93\001\002\000\010\003\u0182\023\u0180\060\u0181" +
    "\001\002\000\006\023\u017a\060\u017b\001\002\000\004\006" +
    "\u017c\001\002\000\032\003\uffa3\007\uffa3\033\uffa3\034\uffa3" +
    "\035\uffa3\037\uffa3\040\uffa3\043\uffa3\050\uffa3\051\uffa3\064" +
    "\uffa3\074\uffa3\001\002\000\010\067\362\072\360\074\357" +
    "\001\002\000\006\007\u017e\036\363\001\002\000\004\060" +
    "\u017f\001\002\000\032\003\uff92\007\uff92\033\uff92\034\uff92" +
    "\035\uff92\037\uff92\040\uff92\043\uff92\050\uff92\051\uff92\064" +
    "\uff92\074\uff92\001\002\000\004\006\u0183\001\002\000\032" +
    "\003\uffa7\007\uffa7\033\uffa7\034\uffa7\035\uffa7\037\uffa7\040" +
    "\uffa7\043\uffa7\050\uffa7\051\uffa7\064\uffa7\074\uffa7\001\002" +
    "\000\032\003\uffa1\007\uffa1\033\uffa1\034\uffa1\035\uffa1\037" +
    "\uffa1\040\uffa1\043\uffa1\050\uffa1\051\uffa1\064\uffa1\074\uffa1" +
    "\001\002\000\012\003\u0184\067\362\072\360\074\357\001" +
    "\002\000\004\007\u0188\001\002\000\006\007\u0186\036\363" +
    "\001\002\000\004\060\u0187\001\002\000\032\003\uff96\007" +
    "\uff96\033\uff96\034\uff96\035\uff96\037\uff96\040\uff96\043\uff96" +
    "\050\uff96\051\uff96\064\uff96\074\uff96\001\002\000\004\060" +
    "\u0189\001\002\000\032\003\uff90\007\uff90\033\uff90\034\uff90" +
    "\035\uff90\037\uff90\040\uff90\043\uff90\050\uff90\051\uff90\064" +
    "\uff90\074\uff90\001\002\000\032\003\uffa0\007\uffa0\033\uffa0" +
    "\034\uffa0\035\uffa0\037\uffa0\040\uffa0\043\uffa0\050\uffa0\051" +
    "\uffa0\064\uffa0\074\uffa0\001\002\000\010\010\u018c\012\077" +
    "\013\106\001\002\000\006\023\u018d\060\u018e\001\002\000" +
    "\004\006\u018f\001\002\000\032\003\uffa2\007\uffa2\033\uffa2" +
    "\034\uffa2\035\uffa2\037\uffa2\040\uffa2\043\uffa2\050\uffa2\051" +
    "\uffa2\064\uffa2\074\uffa2\001\002\000\010\067\362\072\360" +
    "\074\357\001\002\000\006\007\u0191\036\363\001\002\000" +
    "\004\060\u0192\001\002\000\032\003\uff91\007\uff91\033\uff91" +
    "\034\uff91\035\uff91\037\uff91\040\uff91\043\uff91\050\uff91\051" +
    "\uff91\064\uff91\074\uff91\001\002\000\010\011\u0194\023\230" +
    "\060\231\001\002\000\020\004\052\013\031\063\046\067" +
    "\051\070\026\071\050\074\027\001\002\000\010\010\u0196" +
    "\012\077\013\106\001\002\000\006\023\u0197\060\u0198\001" +
    "\002\000\004\006\u0199\001\002\000\032\003\uffad\007\uffad" +
    "\033\uffad\034\uffad\035\uffad\037\uffad\040\uffad\043\uffad\050" +
    "\uffad\051\uffad\064\uffad\074\uffad\001\002\000\010\067\362" +
    "\072\360\074\357\001\002\000\006\007\u019b\036\363\001" +
    "\002\000\004\060\u019c\001\002\000\032\003\uff9d\007\uff9d" +
    "\033\uff9d\034\uff9d\035\uff9d\037\uff9d\040\uff9d\043\uff9d\050" +
    "\uff9d\051\uff9d\064\uff9d\074\uff9d\001\002\000\026\003\332" +
    "\033\306\034\302\035\314\037\325\043\310\050\300\051" +
    "\330\064\276\074\275\001\002\000\030\003\332\007\u019f" +
    "\033\306\034\302\035\314\037\325\043\310\050\300\051" +
    "\330\064\276\074\275\001\002\000\032\003\uff5d\007\uff5d" +
    "\033\uff5d\034\uff5d\035\uff5d\037\uff5d\040\uff5d\043\uff5d\050" +
    "\uff5d\051\uff5d\064\uff5d\074\uff5d\001\002\000\006\005\u01a1" +
    "\062\055\001\002\000\004\013\u01a2\001\002\000\004\052" +
    "\u01a3\001\002\000\004\006\uff7a\001\002\000\004\060\u01a8" +
    "\001\002\000\006\003\u01a7\060\u01a6\001\002\000\032\003" +
    "\uff86\007\uff86\033\uff86\034\uff86\035\uff86\037\uff86\040\uff86" +
    "\043\uff86\050\uff86\051\uff86\064\uff86\074\uff86\001\002\000" +
    "\032\003\uff83\007\uff83\033\uff83\034\uff83\035\uff83\037\uff83" +
    "\040\uff83\043\uff83\050\uff83\051\uff83\064\uff83\074\uff83\001" +
    "\002\000\032\003\uff85\007\uff85\033\uff85\034\uff85\035\uff85" +
    "\037\uff85\040\uff85\043\uff85\050\uff85\051\uff85\064\uff85\074" +
    "\uff85\001\002\000\004\013\u01ca\001\002\000\004\006\u01c7" +
    "\001\002\000\004\064\u01c5\001\002\000\010\004\uff73\042" +
    "\uff73\066\uff73\001\002\000\020\004\uff71\013\uff71\063\uff71" +
    "\067\uff71\070\uff71\071\uff71\074\uff71\001\002\000\004\013" +
    "\uff6e\001\002\000\004\006\u01c2\001\002\000\004\042\u01bf" +
    "\001\002\000\020\004\052\013\031\063\046\067\051\070" +
    "\026\071\050\074\027\001\002\000\010\004\u01ad\042\u01b3" +
    "\066\u01ae\001\002\000\004\064\u01b9\001\002\000\010\004" +
    "\uff72\042\uff72\066\uff72\001\002\000\004\042\u01b6\001\002" +
    "\000\004\064\u01b7\001\002\000\004\060\u01b8\001\002\000" +
    "\032\003\uff75\007\uff75\033\uff75\034\uff75\035\uff75\037\uff75" +
    "\040\uff75\043\uff75\050\uff75\051\uff75\064\uff75\074\uff75\001" +
    "\002\000\004\060\u01ba\001\002\000\032\003\uff77\007\uff77" +
    "\033\uff77\034\uff77\035\uff77\037\uff77\040\uff77\043\uff77\050" +
    "\uff77\051\uff77\064\uff77\074\uff77\001\002\000\006\005\u01bc" +
    "\062\055\001\002\000\004\013\u01bd\001\002\000\004\052" +
    "\u01be\001\002\000\004\006\uff70\001\002\000\004\064\u01c0" +
    "\001\002\000\004\060\u01c1\001\002\000\032\003\uff76\007" +
    "\uff76\033\uff76\034\uff76\035\uff76\037\uff76\040\uff76\043\uff76" +
    "\050\uff76\051\uff76\064\uff76\074\uff76\001\002\000\026\003" +
    "\332\033\306\034\302\035\314\037\325\043\310\050\300" +
    "\051\330\064\276\074\275\001\002\000\030\003\332\007" +
    "\u01c4\033\306\034\302\035\314\037\325\043\310\050\300" +
    "\051\330\064\276\074\275\001\002\000\004\042\uff6c\001" +
    "\002\000\004\060\u01c6\001\002\000\032\003\uff78\007\uff78" +
    "\033\uff78\034\uff78\035\uff78\037\uff78\040\uff78\043\uff78\050" +
    "\uff78\051\uff78\064\uff78\074\uff78\001\002\000\026\003\332" +
    "\033\306\034\302\035\314\037\325\043\310\050\300\051" +
    "\330\064\276\074\275\001\002\000\030\003\332\007\u01c9" +
    "\033\306\034\302\035\314\037\325\043\310\050\300\051" +
    "\330\064\276\074\275\001\002\000\010\004\uff6f\042\uff6f" +
    "\066\uff6f\001\002\000\004\052\u01cb\001\002\000\004\006" +
    "\uff6d\001\002\000\032\003\uff47\007\uff47\033\uff47\034\uff47" +
    "\035\uff47\037\uff47\040\uff47\043\uff47\050\uff47\051\uff47\064" +
    "\uff47\074\uff47\001\002\000\006\060\u01ce\062\055\001\002" +
    "\000\032\003\uff46\007\uff46\033\uff46\034\uff46\035\uff46\037" +
    "\uff46\040\uff46\043\uff46\050\uff46\051\uff46\064\uff46\074\uff46" +
    "\001\002\000\004\004\u01d0\001\002\000\022\003\u01d1\004" +
    "\uff7b\013\uff7b\063\uff7b\067\uff7b\070\uff7b\071\uff7b\074\uff7b" +
    "\001\002\000\004\005\u01d2\001\002\000\004\013\u01d3\001" +
    "\002\000\004\052\u01d4\001\002\000\004\006\u01d5\001\002" +
    "\000\026\003\332\033\306\034\302\035\314\037\325\043" +
    "\310\050\300\051\330\064\276\074\275\001\002\000\030" +
    "\003\332\007\u01d7\033\306\034\302\035\314\037\325\043" +
    "\310\050\300\051\330\064\276\074\275\001\002\000\004" +
    "\042\u01d8\001\002\000\004\064\u01d9\001\002\000\004\060" +
    "\u01da\001\002\000\032\003\uff74\007\uff74\033\uff74\034\uff74" +
    "\035\uff74\037\uff74\040\uff74\043\uff74\050\uff74\051\uff74\064" +
    "\uff74\074\uff74\001\002\000\026\003\u01e5\004\052\013\031" +
    "\063\046\067\051\070\026\071\050\072\045\073\037\074" +
    "\027\001\002\000\020\004\052\013\031\063\046\067\051" +
    "\070\026\071\050\074\027\001\002\000\010\010\u01de\012" +
    "\077\013\106\001\002\000\004\023\u01df\001\002\000\022" +
    "\004\052\013\031\063\046\067\051\070\026\071\050\072" +
    "\u01e1\074\027\001\002\000\010\012\077\013\106\060\u01e3" +
    "\001\002\000\004\060\u01e2\001\002\000\032\003\uff88\007" +
    "\uff88\033\uff88\034\uff88\035\uff88\037\uff88\040\uff88\043\uff88" +
    "\050\uff88\051\uff88\064\uff88\074\uff88\001\002\000\032\003" +
    "\uff89\007\uff89\033\uff89\034\uff89\035\uff89\037\uff89\040\uff89" +
    "\043\uff89\050\uff89\051\uff89\064\uff89\074\uff89\001\002\000" +
    "\006\003\u01e8\060\u01e7\001\002\000\004\060\u01e6\001\002" +
    "\000\034\003\uffb3\007\uffb3\033\uffb3\034\uffb3\035\uffb3\037" +
    "\uffb3\040\uffb3\043\uffb3\044\uffb3\050\uffb3\051\uffb3\064\uffb3" +
    "\074\uffb3\001\002\000\034\003\uffb4\007\uffb4\033\uffb4\034" +
    "\uffb4\035\uffb4\037\uffb4\040\uffb4\043\uffb4\044\uffb4\050\uffb4" +
    "\051\uffb4\064\uffb4\074\uffb4\001\002\000\034\003\uffb1\007" +
    "\uffb1\033\uffb1\034\uffb1\035\uffb1\037\uffb1\040\uffb1\043\uffb1" +
    "\044\uffb1\050\uffb1\051\uffb1\064\uffb1\074\uffb1\001\002\000" +
    "\004\044\u01ec\001\002\000\004\023\u01db\001\002\000\004" +
    "\023\337\001\002\000\006\067\u01ee\070\u01ed\001\002\000" +
    "\006\045\u01f6\046\u01f5\001\002\000\006\045\u01f0\046\u01ef" +
    "\001\002\000\004\067\u01f3\001\002\000\004\067\u01f1\001" +
    "\002\000\004\047\u01f2\001\002\000\004\006\uff61\001\002" +
    "\000\004\047\u01f4\001\002\000\004\006\uff60\001\002\000" +
    "\004\070\u01f9\001\002\000\004\070\u01f7\001\002\000\004" +
    "\047\u01f8\001\002\000\004\006\uff5f\001\002\000\004\047" +
    "\u01fa\001\002\000\004\006\uff5e\001\002\000\006\005\uff4a" +
    "\036\uff4a\001\002\000\006\005\uff4c\036\uff4c\001\002\000" +
    "\016\024\uff52\025\uff52\026\uff52\027\uff52\030\uff52\031\uff52" +
    "\001\002\000\004\006\267\001\002\000\016\024\uff51\025" +
    "\uff51\026\uff51\027\uff51\030\uff51\031\uff51\001\002\000\014" +
    "\024\263\025\257\026\264\027\255\030\256\001\002\000" +
    "\004\005\uff4f\001\002\000\006\005\uff4e\036\u0200\001\002" +
    "\000\004\005\uff4d\001\002\000\006\005\uff4b\036\uff4b\001" +
    "\002\000\006\005\uff48\036\uff48\001\002\000\006\005\uff49" +
    "\036\uff49\001\002\000\004\004\uff53\001\002\000\004\004" +
    "\uff55\001\002\000\004\004\uff54\001\002\000\004\004\u020b" +
    "\001\002\000\004\005\u020c\001\002\000\004\006\uff26\001" +
    "\002\000\004\004\uff56\001\002\000\004\002\uff25\001\002" +
    "\000\004\074\u0212\001\002\000\004\074\u0211\001\002\000" +
    "\004\060\350\001\002\000\004\060\376\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0210\000\006\062\003\063\004\001\001\000\006\015" +
    "\010\050\007\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\024\046\241\047\250\060\246\061" +
    "\235\071\251\072\237\073\245\074\242\075\247\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\034\002\027\003\035\004\040" +
    "\005\042\006\033\007\037\010\032\011\034\012\053\013" +
    "\041\014\043\021\052\055\031\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\032\002\027\003\035\004\040\005\042\006\033\007\037" +
    "\010\032\011\034\012\063\013\041\021\052\055\031\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\032\002\027\003\035\004\040\005\042\006\033\007" +
    "\037\010\032\011\034\012\060\013\041\021\052\055\031" +
    "\001\001\000\002\001\001\000\002\001\001\000\030\002" +
    "\027\003\035\004\040\005\042\006\033\007\037\010\032" +
    "\011\055\013\041\021\052\055\031\001\001\000\002\001" +
    "\001\000\026\002\027\003\035\004\040\005\042\006\033" +
    "\007\037\010\032\013\057\021\052\055\031\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\020\002\027\003\035\006\075\007\037\010\032" +
    "\021\052\055\031\001\001\000\020\002\027\003\035\006" +
    "\074\007\037\010\032\021\052\055\031\001\001\000\020" +
    "\002\027\003\035\006\073\007\037\010\032\021\052\055" +
    "\031\001\001\000\020\002\027\003\035\006\072\007\037" +
    "\010\032\021\052\055\031\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\022" +
    "\002\027\003\035\005\116\006\033\007\037\010\032\021" +
    "\052\055\031\001\001\000\024\002\027\003\035\004\115" +
    "\005\042\006\033\007\037\010\032\021\052\055\031\001" +
    "\001\000\024\002\027\003\035\004\114\005\042\006\033" +
    "\007\037\010\032\021\052\055\031\001\001\000\024\002" +
    "\027\003\035\004\113\005\042\006\033\007\037\010\032" +
    "\021\052\055\031\001\001\000\024\002\027\003\035\004" +
    "\112\005\042\006\033\007\037\010\032\021\052\055\031" +
    "\001\001\000\024\002\027\003\035\004\111\005\042\006" +
    "\033\007\037\010\032\021\052\055\031\001\001\000\024" +
    "\002\027\003\035\004\110\005\042\006\033\007\037\010" +
    "\032\021\052\055\031\001\001\000\022\002\027\003\035" +
    "\005\106\006\033\007\037\010\032\021\052\055\031\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\002\027\003\035\006\121\007\037\010" +
    "\032\021\052\055\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\021\135\056\133\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\002\027" +
    "\003\035\004\130\005\042\006\033\007\037\010\032\021" +
    "\052\055\031\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\057\143\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\057\142" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\021\150\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\034\002\027\003\035\004\040\005\042\006\033\007\037" +
    "\010\032\011\034\012\053\013\041\014\162\021\052\055" +
    "\031\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\034\002\027\003\035\004\040\005" +
    "\042\006\033\007\037\010\032\011\034\012\053\013\041" +
    "\014\174\021\052\055\031\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\034\002\027\003\035\004\040\005\042\006\033" +
    "\007\037\010\032\011\034\012\053\013\041\014\206\021" +
    "\052\055\031\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\034\002\027\003\035\004" +
    "\040\005\042\006\033\007\037\010\032\011\034\012\053" +
    "\013\041\014\220\021\052\055\031\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\034\002\027\003\035\004\040\005\042" +
    "\006\033\007\037\010\032\011\034\012\053\013\041\014" +
    "\231\021\052\055\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\024\u020d\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\051\260\052\257" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\053\u0200\001\001\000\002\001\001\000\004" +
    "\024\u01fc\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\024\267\001\001\000\050\015\270" +
    "\016\306\017\314\020\272\022\271\023\315\025\323\026" +
    "\304\027\316\030\312\031\311\032\303\035\317\036\322" +
    "\037\300\054\321\064\302\067\320\070\273\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\016\u01e8\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\032\002\027\003\035" +
    "\004\040\005\042\006\033\007\037\010\032\011\034\012" +
    "\u01cc\013\041\021\052\055\031\001\001\000\020\040\u01b1" +
    "\041\u01ab\042\u01a9\043\u01ae\044\u01af\065\u01b0\066\u01a8\001" +
    "\001\000\002\001\001\000\032\002\027\003\035\004\040" +
    "\005\042\006\033\007\037\010\032\011\034\012\u019f\013" +
    "\041\021\052\055\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\052\015\270" +
    "\016\306\017\314\020\272\022\326\025\323\026\304\027" +
    "\316\030\312\031\311\032\303\033\u011f\034\330\035\317" +
    "\036\322\037\300\054\321\064\302\067\320\070\273\001" +
    "\001\000\002\001\001\000\002\001\001\000\046\015\270" +
    "\016\306\017\314\020\272\022\u010e\025\323\026\304\027" +
    "\316\030\312\031\311\032\303\035\317\036\322\037\300" +
    "\054\321\064\302\067\320\070\273\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\052\015\270\016\306\017\314\020\272\022\326\025\323" +
    "\026\304\027\316\030\312\031\311\032\303\033\332\034" +
    "\330\035\317\036\322\037\300\054\321\064\302\067\320" +
    "\070\273\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\050\015\270\016\306" +
    "\017\314\020\272\022\333\025\323\026\304\027\316\030" +
    "\312\031\311\032\303\034\335\035\317\036\322\037\300" +
    "\054\321\064\302\067\320\070\273\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\034\002\027" +
    "\003\035\004\040\005\042\006\033\007\037\010\032\011" +
    "\034\012\053\013\041\014\u010b\021\052\055\031\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\024\002" +
    "\027\003\035\004\351\005\042\006\033\007\037\010\032" +
    "\021\052\055\031\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\045\360" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\002\027\003\035\004\377\005\042\006\033" +
    "\007\037\010\032\021\052\055\031\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\045\u0104\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\050\015" +
    "\270\016\306\017\314\020\272\022\333\025\323\026\304" +
    "\027\316\030\312\031\311\032\303\034\335\035\317\036" +
    "\322\037\300\054\321\064\302\067\320\070\273\001\001" +
    "\000\002\001\001\000\032\002\027\003\035\004\040\005" +
    "\042\006\033\007\037\010\032\011\034\012\u0122\013\041" +
    "\021\052\055\031\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\002\027\003\035\004\u0150\005\042\006\033" +
    "\007\037\010\032\021\052\055\031\001\001\000\024\002" +
    "\027\003\035\004\u0133\005\042\006\033\007\037\010\032" +
    "\021\052\055\031\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\045\u0139\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\045\u0141\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\045\u0149\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\045\u0155\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\024\002\027\003\035\004" +
    "\u0159\005\042\006\033\007\037\010\032\021\052\055\031" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\045\u015e\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\024\002\027\003\035\004\u0164" +
    "\005\042\006\033\007\037\010\032\021\052\055\031\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\045\u0169\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\002\027" +
    "\003\035\004\u018a\005\042\006\033\007\037\010\032\021" +
    "\052\055\031\001\001\000\024\002\027\003\035\004\u016e" +
    "\005\042\006\033\007\037\010\032\021\052\055\031\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\045\u0174\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\045\u017c\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\045\u0184\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\045\u018f\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\002\027\003\035\004\u0194\005\042\006\033" +
    "\007\037\010\032\021\052\055\031\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\045\u0199\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\052\015\270\016\306\017\314" +
    "\020\272\022\326\025\323\026\304\027\316\030\312\031" +
    "\311\032\303\033\u019d\034\330\035\317\036\322\037\300" +
    "\054\321\064\302\067\320\070\273\001\001\000\050\015" +
    "\270\016\306\017\314\020\272\022\333\025\323\026\304" +
    "\027\316\030\312\031\311\032\303\034\335\035\317\036" +
    "\322\037\300\054\321\064\302\067\320\070\273\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\032\002\027\003\035" +
    "\004\040\005\042\006\033\007\037\010\032\011\034\012" +
    "\u01ba\013\041\021\052\055\031\001\001\000\016\041\u01b3" +
    "\042\u01a9\043\u01ae\044\u01b4\065\u01b0\066\u01a8\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\052\015\270\016\306" +
    "\017\314\020\272\022\326\025\323\026\304\027\316\030" +
    "\312\031\311\032\303\033\u01c2\034\330\035\317\036\322" +
    "\037\300\054\321\064\302\067\320\070\273\001\001\000" +
    "\050\015\270\016\306\017\314\020\272\022\333\025\323" +
    "\026\304\027\316\030\312\031\311\032\303\034\335\035" +
    "\317\036\322\037\300\054\321\064\302\067\320\070\273" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\052\015\270\016\306\017\314\020\272\022\326" +
    "\025\323\026\304\027\316\030\312\031\311\032\303\033" +
    "\u01c7\034\330\035\317\036\322\037\300\054\321\064\302" +
    "\067\320\070\273\001\001\000\050\015\270\016\306\017" +
    "\314\020\272\022\333\025\323\026\304\027\316\030\312" +
    "\031\311\032\303\034\335\035\317\036\322\037\300\054" +
    "\321\064\302\067\320\070\273\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\052\015\270\016\306\017\314" +
    "\020\272\022\326\025\323\026\304\027\316\030\312\031" +
    "\311\032\303\033\u01d5\034\330\035\317\036\322\037\300" +
    "\054\321\064\302\067\320\070\273\001\001\000\050\015" +
    "\270\016\306\017\314\020\272\022\333\025\323\026\304" +
    "\027\316\030\312\031\311\032\303\034\335\035\317\036" +
    "\322\037\300\054\321\064\302\067\320\070\273\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\034\002\027\003\035\004\040\005\042" +
    "\006\033\007\037\010\032\011\034\012\053\013\041\014" +
    "\u01e3\021\052\055\031\001\001\000\024\002\027\003\035" +
    "\004\u01dc\005\042\006\033\007\037\010\032\021\052\055" +
    "\031\001\001\000\002\001\001\000\002\001\001\000\024" +
    "\002\027\003\035\004\u01df\005\042\006\033\007\037\010" +
    "\032\021\052\055\031\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\024" +
    "\u01fe\001\001\000\002\001\001\000\004\052\u0201\001\001" +
    "\000\002\001\001\000\004\053\u0202\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    public static int syntaxErrors = 0;
    public static int erroresSemanticos = 0;
    
    public void syntax_error(Symbol s) {
        syntaxErrors++;
        System.err.println("\n ERROR DE SINTAXIS:");
        System.err.println("   Linea: " + (s.left+1));
        System.err.println("   Token inesperado: " + s.value);
    }
    
    public String revisarTemporal(){
        

        if(codigo.Lexer.hayFloat){
            String temp = "f" + contadorTemporalFloat;
            contadorTemporalFloat++;
            return temp;
        } else
        {
            String temp = "t" + contadorTemporalInt;
            contadorTemporalInt++;
            return temp;
        }
    }

    public void report_error(String message, Object info) {
        System.err.println("ERROR: " + message);
    }
    
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.err.println("\nERROR FATAL: No se puede recuperar del error de sintaxis");
        throw new Exception("Error de sintaxis irrecuperable en linea " + (s.left+1));
    }

    public void sePuedeoNo(){
        int lexerErrors = codigo.Lexer.errorCount; 
        
        if (lexerErrors == 0 && syntaxErrors == 0) {
            System.out.println("La gramatica si puede ser generada");
        }
        else {
            System.out.println("La gramatica no puede ser generada");
            System.out.println("Numero de errores en el lexer: " + lexerErrors); 
            System.out.println("Numero de errores en el parser: " + syntaxErrors);
            
        }
    }



// Funciones que se necesitan para el cdigo de tres direcciones

    int contadorTemporalINT = 1;
    int contadorTemporalINTG = 1; // Este va a ser solo como para direcciones
    int contadorTemporalFLOAT = 1;
    int contadorTemporalFLOATG = 1; // Este va a ser solo para direcciones de float 



    int contadorBloque = 1;
    int contadorIF = 1;
    int encabezado = 1;
    int contadorFor = 1;
    boolean UltimoElif = false;
    boolean existeElif = false;
    int contadorFuncINT = 1;
    int contadorFuncFLOAT = 1;
    int contadorFuncCHAR = 1;
    int contadorFuncSTRING = 1;
    int contadorFuncBOOL = 1;
    int contadorFuncVOID = 1;
    StringBuffer C3D = new StringBuffer();


    boolean funcFloat = false;
    boolean funcInt = false;
    boolean funcChar = false;
    boolean funcString = false;
    boolean funcBool = false;
    boolean funcVoid = false;
    
    public String registroTemporalI()
    {
        String temp = "t" + contadorTemporalINT;
        contadorTemporalINT++;
        return temp;
    }

    public String registroTemporalF(){
        String temp = "f" + contadorTemporalFLOAT;
        contadorTemporalFLOAT++;
        return temp;
    }


    // Esto puede ser que lo quuite 
    // Porque no s si el break va en el decide of 
    ArrayList<String> direccionesBreak = new ArrayList<>();
    public void AgregarDireccion(String direccion) {
        direccionesBreak.add(direccion);
        System.out.println("DEBUG - direcccion break: " + direccion);
    }

    public String obtenerDireccionActual() {
        if (!direccionesBreak.isEmpty()) {
            return direccionesBreak.get(direccionesBreak.size() - 1);
        } else {
            System.err.println("Error Semantico: break fuera de estructura de control");
            return "ERROR";
        }
    }

    public void eliminarDireccionBreak() {
        if (!direccionesBreak.isEmpty()) {
            String direccion = direccionesBreak.remove(direccionesBreak.size() - 1);
            System.out.println("DEBUG - direccion break quitadc|: " + direccion);
        }
    }


    public DatoT crearDatoT(String tipo, String lexema, String direccion){
        return new DatoT(tipo, lexema, direccion); 
    }

    public String empiezaFunc(String nombreFuncion){
        return nombreFuncion + ":\n";
    }

    public String terminaFunc(String nombreFuncion){
        return nombreFuncion + "_end:\n";
    }

    public String mostrarVariable(String tipo, String nombre){
        return "data_ " + tipo + " " + nombre + ";\n";
    }

    public String crearParam(String tipo, String valor){
        return "param " + tipo + " " + valor + ";\n"; 
    }

    public void mostrarCodigo3Direcciones(){
        int lexerErrors = codigo.Lexer.errorCount;
        int syntaxErrors = codigo.parser.syntaxErrors;
        int ErroresSemanticos = codigo.parser.erroresSemanticos;
        if(lexerErrors > 0 || syntaxErrors > 0 || ErroresSemanticos > 0){
            System.out.println("No se puede generar el cdigo de tres direcciones ya que todava hay errores en el sistema.");
            return;
        }
        System.out.println("Cdigo de tres direcciones generado:");
        System.out.println(C3D.toString());
    }

    public boolean esLiteral(String valor){
        if(!valor.matches("t[0-9]+")){
            return true; // seria literal
        }
        else {
            return false; // sino
        }
    }

    public boolean esLiteralVerdadero(String valor){
        return valor.matches("^-?\\d+(\\.\\d+)?$")  || valor.matches("^'.'$")               
            || valor.matches("^\".*\"$") || valor.matches("^(True|False)$");     
    }


    public boolean esBool(String valor){
        if(!valor.matches("True|False")){
            return true; // seria booleano
        }
        else {
            return false; // sino
        }
    }

    public boolean esChar(String valor){
        if(!valor.matches("'[a-zA-Z]'")){
            return true; // seria char
        }
        else {
            return false; // sino
        }
    }

    public boolean esString(String valor){
        if(!valor.matches("\"[^\"]*\"")){
            return true; // seria string
        }
        else {
            return false; // sino
        }
    }

    public boolean esTemporal(String valor){
        if (valor.matches("t[0-9]+")){
            return true; 
        }
        else {
            return false;
        }
    }

    int[] array = {1,2,3,4,5,7,8,9};


    public boolean continuouNo(String valor){
        if (valor.matches("t[0-9]+")){
            System.out.println("Es un temporal");
            return true; 
        }
    

        
        System.out.println("Valor en continuouNo: " + valor);
        for (int i : array) {
            if (valor.equals(String.valueOf(i))) {

                return false;
            }
        }
        return false;
    }
    public boolean continuoLogico(String valor){
        if(valor.matches("[0-9]>=|<=|==|!=|>|<[0-9]+")){
            return true; // o sea es algo como 5 > 3
        }
        // Si no entonces es un temporal como t1 > t2
        else {
            return false;
        }
    }
    




//////////////////////////////////////////////////////////




/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {

 
    TablaDeFunciones tablaDeFunciones = new TablaDeFunciones();
    TablaDeSimbolos tablaGlobal = new TablaDeSimbolos("Global"); //
    TablaDeSimbolos tablaActual = tablaGlobal; //Al principio es la global
    String funcionActual = "";

    int erroresSemanticos = 0;
    public void hola(){
         System.out.println(tablaActual.toString());
    }
    



    public String verificacionAritmeticaDivisionFlotante(String tipo1, String tipo2, String linea1, String linea2, String columna1, String columna2){
        boolean tipo1b = true;
        boolean tipo2b = true;

        if(!(tipo1.equals("float"))){
            System.err.println(String.format(
                "Error Semantico: El operando izquierdo de la division en la linea %s columna %s debe ser flotante.", 
                linea1, columna1
            ));
            erroresSemanticos++;
            tipo1b = false;
        }

        if(!(tipo2.equals("float"))){
            System.err.println(String.format(
                "Error Semantico: El operando derecho de la division en la linea %s columna %s debe ser flotante.",
                linea2, columna2
            ));
            erroresSemanticos++;
            tipo2b = false;
        }

        if(tipo1b && tipo2b && tipo1.equals(tipo2)){
            return tipo1;
        } else {
            System.err.println(String.format(
                "Error Semantico: Ambos operandos en la division de la linea %s deben ser flotantes.",
                linea1
            ));
            erroresSemanticos++;
            return "null";
        }
    }

    public String verificacionAritmeticaDivisionEntera(String tipo1, String tipo2, String linea1, String linea2, String columna1, String columna2){
        boolean tipo1b = true;
        boolean tipo2b = true;

        if(!(tipo1.equals("int"))){
            System.err.println(String.format(
                "Error Semantico: El operando izquierdo de la division entera en la linea %s columna %s debe ser entero.", 
                linea1, columna1
            ));
            erroresSemanticos++;
            tipo1b = false;
        }

        if(!(tipo2.equals("int"))){
            System.err.println(String.format(
                "Error Semantico: El operando derecho de la division entera en la linea %s columna %s debe ser entero.",
                linea2, columna2
            ));
            erroresSemanticos++;
            tipo2b = false;
        }

        if(tipo1b && tipo2b && tipo1.equals(tipo2)){
            return tipo1;
        } else {
            System.err.println(String.format(
                "Error Semantico: Ambos operandos en la division de la linea %s deben ser enteros.",
                linea1
            ));
            erroresSemanticos++;
            return "null";
        }
    }


    //Se crea una nueva tabla de smbolos
    public TablaDeSimbolos crearTablaDeSimbolos(String nombre){
        return new TablaDeSimbolos(nombre);
    }
    
    //Le coloca a la tabla que se pase como parametro la actual como anterior, y coloca la del parmetro de entrada como actual
    public void apilarNuevaTablaDeSimbolos(TablaDeSimbolos pTablaDeSimbolos){
        //La tabla actual la coloco como la anterior de la recibida en la entrada
        pTablaDeSimbolos.setTablaAnterior(tablaActual);
        
        //Coloco la tabla de la entrada como la nueva
        tablaActual = pTablaDeSimbolos;
    }

    //Coloca la tabla anterior a la actual como la nueva tabla actual
    public void desapilarTablaDeSimbolos(){
        System.out.println("Voy a desapilar tabla: " + tablaActual.getNombre());
        TablaDeSimbolos tablaAnterior = tablaActual.getTablaAnterior();
        if(tablaAnterior != null){
            
            tablaActual = tablaAnterior; //Con esto ya no hay referencia a la primera tabla de la pila
            System.out.println("La tabla actual es ahora: " + tablaActual.getNombre());
        }else{
            System.out.println("Error: Se est intentando desapilar la tabla Global");
        }
    }

    //Aade a la tabla actual el smbolo indicado. VERIFICAR SI EL SMBOLO YA EST EN LA TABLA ACTUAL.
    public void agregarSimbolo(String pTipo, String pSimbolo){
        System.out.println("Se agrega el simbolo " + pSimbolo + " a la tabla "+tablaActual.getNombre() + " con el tipo "+ pTipo);
        tablaActual.agregarSimbolo(new Simbolo(pSimbolo, pTipo));
    }

    //Aade a la tabla actual el smbolo indicado. VERIFICAR SI EL SMBOLO YA EST EN LA TABLA ACTUAL.
    public void agregarSimboloArray(String pTipo, String pSimbolo, String pTamanio, ArrayList<Simbolo> pElementosArreglo){
        System.out.println("Se agrega el simbolo " + pSimbolo + " a la tabla "+tablaActual.getNombre() + " con el tipo "+ pTipo);
        tablaActual.agregarSimbolo(new SimboloArreglo(pSimbolo, pTipo, pTamanio, pElementosArreglo));
    }
    
    //Busca en la jerarqua de tablas el smbolo de la entrada y lo retorno si existiera
    public Simbolo buscarSimbolo(String pSimbolo){
        return tablaActual.obtenerSimbolo(pSimbolo);
    }

    //Reporta el error de que ese id no existe en la tabla
    public void reportarErrorNoExisteSimbolo(String pSimbolo){
        Simbolo simbolo = buscarSimbolo(pSimbolo);
        if(simbolo == null){
            System.err.println("Error Semantico: El identificador " + pSimbolo + " no ha sido declarado previamente");
            erroresSemanticos++;
            parser.erroresSemanticos++;
        }
    }

    public String verifiacionSemanticaAritmeticaBinaria(String operacion,String tipo1, String tipo2, String linea1, String linea2, String columna1, String columna2){
        boolean tipo1b = true;
        boolean tipo2b = true;

        if(!(tipo1.equals("int") || tipo1.equals("float"))){
            System.err.println(String.format(
                "Error Semantico: El operando izquierdo de la %s en la linea %s columna %s debe ser entero o flotante.", 
                operacion, linea1, columna1
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            tipo1b = false;
        }

        if(!(tipo2.equals("int") || tipo2.equals("float"))){
            System.err.println(String.format(
                "Error Semantico: El operando derecho de la %s en la linea %s columna %s debe ser entero o flotante.",
                operacion, linea2, columna2
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            tipo2b = false;
        }

        if(tipo1b && tipo2b && tipo1.equals(tipo2)){
            return tipo1;
        } else {
            System.err.println(String.format(
                "Error Semantico: Ambos operandos en la %s de la linea %s deben ser enteros o flotantes.",
                operacion, linea1
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            return "null";
        }
    }
    
    //Esto es para cuando se quiere hacer arreglo[i+2] = 5*1$
    public void agregarElementoArregloPosicionEspecifica(String nombreArreglo, int linea, String tipoPosicion, String tipoElementoAsignado, String posicionArreglo, String elementoAsignado){
        //Verificar que el identificador exista,
        Simbolo simbolo = buscarSimbolo(nombreArreglo);
        if(simbolo == null){
            System.err.println("Error Semantico: El identificador " + nombreArreglo + " no ha sido declarado previamente. Linea " + linea);
            erroresSemanticos++;
            parser.erroresSemanticos++;
        }else{
            //Verificar que el identificador sea un arreglo
            if(simbolo.getTipo().equals("arrayChar") | simbolo.getTipo().equals("arrayInt")){
                //Verificar que el tipo de la expresin que me indica la posicin sea entero
                if(!(tipoPosicion.equals("int"))){
                    System.err.println("Error Semantico: La expresion que indica la posicion donde se asignara el elemento en el arreglo " + nombreArreglo + " debe ser de tipo int. Linea " + linea);
                    erroresSemanticos++;
                    parser.erroresSemanticos++;
                }else{
                    //Verificar que el tipo del arreglo sea el mismo del elemento que se quiere asignar
                    if(simbolo.getTipo().toLowerCase().contains(tipoElementoAsignado)) {
                        //Aqu ya debera de hacer el movimiento y meter el elemento en el arreglo
                        System.out.println("Se agrega elemento a arreglo");
                    }else{
                        System.err.println("Error Semantico: El tipo de la expresion que se quiere agregar al arreglo " + nombreArreglo + " no coincide con el del arreglo. Linea " + linea);
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                        }
                }  
            }
            else{
                System.err.println("Error Semantico: El tipo del identificador " + nombreArreglo + " no es un arreglo. Linea " + linea);
                erroresSemanticos++;
                parser.erroresSemanticos++;
            }
        }

        
    }
        
    //Verifica que el identificador exista, que sea un arreglo, que el tipo de la expresin aritmtica que me indica la posicin sea int y me retorna valor::tipo
    public String accederElementoDeArreglo(String nombreArreglo, String posicionElemento, String tipoPosicionElemento, int linea, int columna){
        Simbolo simbolo = buscarSimbolo(nombreArreglo);
        String retorno = "null::null::" + linea + "::"+columna;
        if(simbolo == null){
            System.err.println("Error Semantico: El identificador " + nombreArreglo + " no ha sido declarado previamente. Linea " + linea);
            erroresSemanticos++;
            parser.erroresSemanticos++;
        }else{
            //Verificar que sea un arreglo
            if(simbolo.getTipo().equals("arrayChar") | simbolo.getTipo().equals("arrayInt")){
               //Verificar que el tipo de la expresion que me indica la posicin sea int 
               if(!(tipoPosicionElemento.equals("int"))){
                    System.err.println("Error Semantico: La expresion que indica la posicion del elemento a tomar en el arreglo " + nombreArreglo + " debe ser de tipo int. Linea " + linea);
                    erroresSemanticos++;
                    parser.erroresSemanticos++;
                }else{
                        if(simbolo.getTipo().equals("arrayChar")){
                            retorno = "desconocido::char::" + linea + "::" + columna; //Hay que resolver esto para poder retornar el valor
                        }else{
                             retorno = "desconocido::int::" + linea + "::" + columna;
                        }
                    }
            }
            else{
                System.err.println("Error Semantico: El tipo del identificador " + nombreArreglo + " no es un arreglo. Linea " + linea);
                erroresSemanticos++;
                parser.erroresSemanticos++;
            }
        }
        return retorno;
    }

    public void agregarFuncion(String pNombre, String pTipo, int linea){
        boolean agregar = tablaDeFunciones.agregarFuncion(pNombre, pTipo);
        funcionActual = pNombre;
        if(!agregar){
            System.err.println("Error Semantico: Ya existe una funcion llamada " + pNombre + " Linea: " + linea);
            erroresSemanticos++;
            parser.erroresSemanticos++;
            funcionActual = "";
        }
    }

    public void agregarParametro(Simbolo pSimbolo){
        tablaDeFunciones.agregarSimboloAFuncion(funcionActual, pSimbolo);
    }

    public String validacionRelacionalNoBoleanos(String operacionTexto , String operacionSimbolo, String operador1 , String operador2 ,String tipo1, String tipo2, String linea1, String linea2, String columna1, String columna2){
        String retorno = operador1 + operacionSimbolo + operador2 + "::null::" + linea1 + "::" + columna1;
        //Verificar que ambos sean enteros o flotantes
        boolean verificacionOperador1 = true;
        boolean verificacionOperador2 = true;

        if(!(tipo1.equals("int") || tipo1.equals("float"))){
            System.err.println(String.format(
                "Error Semantico: El operando izquierdo de la operacion %s en la linea %s columna %s debe ser entero o flotante.", 
                operacionTexto, linea1, columna1
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            verificacionOperador1 = false;
        }

        if(!(tipo2.equals("int") || tipo2.equals("float"))){
            System.err.println(String.format(
                "Error Semantico: El operando derecho de la operacion %s en la linea %s columna %s debe ser entero o flotante.", 
                operacionTexto, linea2, columna2
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            verificacionOperador2 = false;
        }

        //Si pasan las verificaciones se resuelve la expresin
        if(verificacionOperador1 && verificacionOperador2 && (tipo1.equals(tipo2))){
            retorno = operador1 + operacionSimbolo + operador2 + "::bool::" + linea1 + "::" + columna1; 
        } else{   System.err.println(String.format(
                "Error Semantico: Ambos operandos de la operacion %s en la linea %s columna %s debe ser del mismo tipo sean enteros o flotantes.", 
                operacionTexto, linea2, columna2
            ));
            erroresSemanticos++;
        }
        return retorno;
    }

    public String validacionRelacionalConBoleanos(String operacionTexto , String operacionSimbolo, String operador1 , String operador2 ,String tipo1, String tipo2, String linea1, String linea2, String columna1, String columna2){
        String retorno = operador1 + operacionSimbolo + operador2 + "::null::" + linea1 + "::" + columna1;
        //Verificar que ambos sean enteros o flotantes
        boolean verificacionOperador1 = true;
        boolean verificacionOperador2 = true;

        if(!(tipo1.equals("int") || tipo1.equals("float")|| tipo1.equals("bool"))){
            System.err.println(String.format(
                "Error Semantico: El operando izquierdo de la operacion %s en la linea %s columna %s debe ser entero, flotante o booleano.", 
                operacionTexto, linea1, columna1
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            verificacionOperador1 = false;
        }

        if(!(tipo2.equals("int") || tipo2.equals("float")|| tipo2.equals("bool"))){
            System.err.println(String.format(
                "Error Semantico: El operando derecho de la operacion %s en la linea %s columna %s debe ser entero, flotante o booleano.", 
                operacionTexto, linea2, columna2
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            verificacionOperador2 = false;
        }

        //Si pasan las verificaciones se resuelve la expresin
        if(verificacionOperador1 && verificacionOperador2 && (tipo1.equals(tipo2))){
            retorno = operador1 + operacionSimbolo + operador2 + "::bool::" + linea1 + "::" + columna1; 
        }else{
            System.err.println(String.format(
                "Error Semantico: Ambos operandos de la operacion %s en la linea %s columna %s debe ser del mismo tipo sean enteros, flotantes o booleanos.", 
                operacionTexto, linea2, columna2
            ));
            erroresSemanticos++;
        }
        return retorno;
    }

    public String validacionLogicaSoloBoleanos(String operacionTexto , String operacionSimbolo, String operador1 , String operador2 ,String tipo1, String tipo2, String linea1, String linea2, String columna1, String columna2){
        String retorno = operador1 + operacionSimbolo + operador2 + "::null::" + linea1 + "::" + columna1;
        //Verificar que ambos sean enteros o flotantes
        boolean verificacionOperador1 = true;
        boolean verificacionOperador2 = true;

        if(!(tipo1.equals("bool"))){
            System.err.println(String.format(
                "Error Semantico: El operando izquierdo de la operacion %s en la linea %s columna %s debe ser booleano.", 
                operacionTexto, linea1, columna1
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            verificacionOperador1 = false;
        }

        if(!(tipo2.equals("bool"))){
            System.err.println(String.format(
                "Error Semantico: El operando derecho de la operacion %s en la linea %s columna %s debe ser booleano.", 
                operacionTexto, linea2, columna2
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            verificacionOperador2 = false;
        }

        //Si pasan las verificaciones se resuelve la expresin
        if(verificacionOperador1 && verificacionOperador2){
            retorno = operador1 + operacionSimbolo + operador2 + "::bool::" + linea1 + "::" + columna1; 
        }
        return retorno;
    }

    public boolean validacionAsignacion(String identificador, String tipoIdentificador, String tipoExpresion, String linea, String columna){
        if(!(tipoIdentificador.equals(tipoExpresion))){
            System.err.println(String.format(
                "Error Semantico: El identificador %s en la linea %s columna %s es de tipo %s y se le esta intentando asignar una expresion de tipo %s.", 
                identificador, linea, columna, tipoIdentificador, tipoExpresion 
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            return false;
        }
        return true; //Pasa la validacion
    }

    public boolean validacionReasignacion(String identificador, String tipoExpresion, String linea, String columna){
        
        Simbolo simbolo =  tablaActual.obtenerSimbolo(identificador);
        if(simbolo != null){
            if(!(simbolo.getTipo().equals(tipoExpresion))){
            System.err.println(String.format(
                "Error Semantico: El identificador previamente declarado %s es de tipo %s y se le esta intentando asignar una expresion de tipo %s en la linea %s columna %s.", 
                identificador, simbolo.getTipo(), tipoExpresion, linea, columna
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
            return false;
            }else{
                 return true; //Pasa la validacion
            }
       
        }else{
            System.err.println("Error Semantico: El identificador " + identificador + " no ha sido declarado previamente. Linea "+ linea);
            erroresSemanticos++;
            parser.erroresSemanticos++;
            return false;
        }
        
    }




    

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // arithmetic_expression ::= arithmetic_expression plus_operator term 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Suma (+)"); 
                               String[] partesE1 = e1.toString().split("::"); 
                               String[] partesE2 = e2.toString().split("::");
                            String verificacion = verifiacionSemanticaAritmeticaBinaria("suma", partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);

                            String sumaiz = partesE1[0]; // parte izquierda de la suma
                            String sumader = partesE2[0]; // parte derecha de la suma
                            
                            // revisamos si la parte izq es temporal 
                            if(!esTemporal(sumaiz) && esLiteralVerdadero(sumaiz)){ 
                                String tempIzq = registroTemporalI();
                                C3D.append("\n" + tempIzq + " = " + sumaiz + ";\n");
                                sumaiz = tempIzq;
                            }
                            
                            if(!esTemporal(sumader) && esLiteralVerdadero(sumader)){ 
                                String tempDer = registroTemporalI();
                                C3D.append("\n" + tempDer + " = " + sumader + ";\n");
                                sumader = tempDer;
                            }

                            String temp = registroTemporalI();
                            C3D.append("\n" + temp + " = " + sumaiz + " + " + sumader + ";\n");

                            RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];
                            System.out.println(partesE1[0] + "+" + partesE2[0] + "::" + temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3] + "::" + temp);
                          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_expression",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // arithmetic_expression ::= arithmetic_expression plus_operator error 
            {
              Object RESULT =null;
		 System.err.println("Error:En la expresin aritmtica despus de +"); RESULT = "null::null::-1::-1";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_expression",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // arithmetic_expression ::= arithmetic_expression minus_operator term 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Resta (-)"); 
                            String[] partesE1 = e1.toString().split("::");
                            String[] partesE2 = e2.toString().split("::");
                            String verificacion = verifiacionSemanticaAritmeticaBinaria("resta", partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
       

                            String restaIzq = partesE1[0]; // parte izquierda de la resta
                            String restaDer = partesE2[0]; // parte derecha de la resta
                            if(!esTemporal(restaIzq) && esLiteralVerdadero(restaIzq)){ 
                                String tempIzq = registroTemporalI();
                                C3D.append("\n" + tempIzq + " = " + restaIzq + ";\n");
                                restaIzq = tempIzq;
                            }
                            
                            if(!esTemporal(restaDer) && esLiteralVerdadero(restaDer)){ 
                                String tempDer = registroTemporalI();
                                C3D.append("\n" + tempDer + " = " + restaDer + ";\n");
                                restaDer = tempDer;
                            }

                            String temp = registroTemporalI();
                            C3D.append("\n" + temp + " = " + restaIzq + " - " + restaDer + ";\n");


                            // FALTA AGREGARLO EN RESULT
                            RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];
                          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_expression",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // arithmetic_expression ::= arithmetic_expression minus_operator error 
            {
              Object RESULT =null;
		 System.err.println("Error:En la expresin aritmtica despus de -");  RESULT = "null::null::-1::-1";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_expression",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // arithmetic_expression ::= term 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_expression",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // term ::= term multiplication_operator power 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        String[] partesE1 = e1.toString().split("::");
        String[] partesE2 = e2.toString().split("::");
        System.out.println("Multiplicacion (*)"); 
        String verificacion = verifiacionSemanticaAritmeticaBinaria("multiplicacion", partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
       
        String mulIzq = partesE1[0]; // parte izquierda de la multiplicacion
        String mulDer = partesE2[0]; // parte derecha de la multiplicacion
        if(!esTemporal(mulIzq) && esLiteralVerdadero(mulIzq)){ 
            String tempIzq = registroTemporalI();
            C3D.append("\n" + tempIzq + " = " + mulIzq + ";\n");
            mulIzq = tempIzq;
        }
        
        if(!esTemporal(mulDer) && esLiteralVerdadero(mulDer)){ 
            String tempDer = registroTemporalI();
            C3D.append("\n" + tempDer + " = " + mulDer + ";\n");
            mulDer = tempDer;
        }

        String temp = registroTemporalI();
        C3D.append("\n" + temp + " = " + mulIzq + " * " + mulDer + ";\n"); 

        RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];
        
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // term ::= term division_operator power 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Division (/)"); 
        String[] partesE1 = e1.toString().split("::");
        String[] partesE2 = e2.toString().split("::");
        String verificacion = verificacionAritmeticaDivisionFlotante(partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);


        String divsimpleIzq = partesE1[0]; // parte izquierda de la division
        String divsimpleDer = partesE2[0]; // parte derecha de la division
        if(!esTemporal(divsimpleIzq) && esLiteralVerdadero(divsimpleIzq)){ 
            String tempIzq = registroTemporalI();
            C3D.append("\n" + tempIzq + " = " + divsimpleIzq + ";\n");
            divsimpleIzq = tempIzq;
        }
        
        if(!esTemporal(divsimpleDer) && esLiteralVerdadero(divsimpleDer)){ 
            String tempDer = registroTemporalI();
            C3D.append("\n" + tempDer + " = " + divsimpleDer + ";\n");
            divsimpleDer = tempDer;
        }

        String temp = registroTemporalI();
        C3D.append("\n" + temp + " = " + divsimpleIzq + " / " + divsimpleDer + ";\n");
        RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // term ::= term int_division_operator power 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Division entera (//)");
        String[] partesE1 = e1.toString().split("::");
        String[] partesE2 = e2.toString().split("::");
        String verificacion = verificacionAritmeticaDivisionEntera(partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
       

        String diventeraIzq = partesE1[0]; // parte izquierda de la division entera
        String diventeraDer = partesE2[0]; // parte derecha de la division entera
        if(!esTemporal(diventeraIzq) && esLiteralVerdadero(diventeraIzq)){ 
            String tempIzq = registroTemporalI();
            C3D.append("\n" + tempIzq + " = " + diventeraIzq + ";\n");
            diventeraIzq = tempIzq;
        }
        
        if(!esTemporal(diventeraDer) && esLiteralVerdadero(diventeraDer)){ 
            String tempDer = registroTemporalI();
            C3D.append("\n" + tempDer + " = " + diventeraDer + ";\n");
            diventeraDer = tempDer;
        }

        String temp = registroTemporalI();
        C3D.append("\n" + temp + " = " + diventeraIzq + " // " + diventeraDer + ";\n");
        RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];

      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // term ::= term modulo_operator power 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Modulo (%)"); 
        String[] partesE1 = e1.toString().split("::");
        String[] partesE2 = e2.toString().split("::");
        String verificacion = verifiacionSemanticaAritmeticaBinaria("modulo", partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
       
        String moduloIzq = partesE1[0]; // parte izquierda del modulo entera
        String moduloDer = partesE2[0]; // parte derecha del moduloentera
        if(!esTemporal(moduloIzq) && esLiteralVerdadero(moduloIzq)){ 
            String tempIzq = registroTemporalI();
            C3D.append("\n" + tempIzq + " = " + moduloIzq + ";\n");
            moduloIzq = tempIzq;
        }
        
        if(!esTemporal(moduloDer) && esLiteralVerdadero(moduloDer)){ 
            String tempDer = registroTemporalI();
            C3D.append("\n" + tempDer + " = " + moduloDer + ";\n");
            moduloDer = tempDer;
        }

        String temp = registroTemporalI();
        C3D.append("\n" + temp + " = " + moduloIzq + " % " + moduloDer + ";\n");
        RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];

      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // term ::= power 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  RESULT = e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // power ::= factor power_operator power 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Potencia (^)"); 
            //Voy a dejarlo de igual manera que ambos sean enteros o flotantes
            String[] partesE1 = e1.toString().split("::");
            String[] partesE2 = e2.toString().split("::");
            String verificacion = verifiacionSemanticaAritmeticaBinaria("potencia", partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);


        String elevadoIzq = partesE1[0]; // parte izquierda de la potencia
        String elevadoDer = partesE2[0]; // parte derecha de la potencia
        if(!esTemporal(elevadoIzq) && esLiteralVerdadero(elevadoIzq)){ 
            String tempIzq = registroTemporalI();
            C3D.append("\n" + tempIzq + " = " + elevadoIzq + ";\n");
            elevadoIzq = tempIzq;
        }
        
        if(!esTemporal(elevadoDer) && esLiteralVerdadero(elevadoDer)){ 
            String tempDer = registroTemporalI();
            C3D.append("\n" + tempDer + " = " + elevadoDer + ";\n");
            elevadoDer = tempDer;
        }

        String temp = registroTemporalI();
        C3D.append("\n" + temp + " = " + elevadoIzq + " ^ " + elevadoDer + ";\n");
        RESULT = temp + "::" + verificacion + "::" + partesE1[2] + "::" + partesE1[3];

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("power",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // power ::= factor 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("power",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // factor ::= left_parenthesis logical_expresion_and right_parenthesis 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Expresion entre parentesis reconocida"); RESULT = e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // factor ::= arithmetic_operands 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // arithmetic_operands ::= int_literal 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n + "::int::" + (nleft + 1) + "::" + nright;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // arithmetic_operands ::= float_literal 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n + "::float::" + (nleft +1) + "::" + nright; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // arithmetic_operands ::= identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                        //Verificar que exista el identificador
                        reportarErrorNoExisteSimbolo(n);
                        //Obtener el tipo
                        Simbolo simbolo = buscarSimbolo(n);
                        if(simbolo != null){
                            RESULT =  simbolo.getSimbolo() + "::" + simbolo.getTipo() + "::"  + (nleft +1) + "::" + nright; //valor::tipo::linea::columna
                        }else{
                            RESULT = "null::null::" + (nleft + 1) + "::" + nright;
                            erroresSemanticos++;
                            parser.erroresSemanticos++;
                        }
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // arithmetic_operands ::= unary_negative 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // arithmetic_operands ::= postfix_expression 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // arithmetic_operands ::= array_access 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n; System.out.println("Operando acceso array: " + n);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // arithmetic_operands ::= function_call 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n; System.out.println("Operando funcion: " + n); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // arithmetic_operands ::= bool_literal 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = n + "::bool::" + (nleft +1) + "::" + nright;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // arithmetic_operands ::= not_operator logical_expresion_and 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            //Revisar que la expresin sea booleana
                            String[] partesExpresion = e.toString().split("::");
                            if(!(partesExpresion[1].equals("bool"))){
                                //Error 
                                System.err.println("Error Semantico: La expresion " + partesExpresion[0] + " debe ser de tipo booleano para poder aplicarle la negacion. Linea "+ (ileft +1));
                                erroresSemanticos++;
                                parser.erroresSemanticos++;
                                RESULT = ""+ partesExpresion[0] + "::null::" + (ileft +1) + "::" + iright;
                            }else{
                                RESULT = "/"+ partesExpresion[0] + "::bool::" + (ileft +1) + "::" + iright;
                            }
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arithmetic_operands",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // unary_negative ::= minus_operator int_literal 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Negativo entero"); 
                String temp2 = registroTemporalI();
                String temp3 = registroTemporalI();
                String temp = registroTemporalI();
                    C3D.append("\n" + temp2 + "=" + "-1" + "\n");
                    C3D.append("\n" + temp3 + " = " +  n + "\n");
                    
                    C3D.append("\n" + temp + " = " +  temp3 + "*"  + temp2 + ";\n");

                    RESULT = temp + "::int::" + (nleft +1) + "::" + nright;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary_negative",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // unary_negative ::= minus_operator float_literal 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Negativo flotante"); 
                    String temp = registroTemporalF();
                    C3D.append("\n" + temp + " = " + " - " + n + ";\n");
                        RESULT = temp  + "::float::" + (nleft +1) + "::" + nright;
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary_negative",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // postfix_expression ::= identifier increment_operator 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Incremento (++)"); 
                            //Verificar que el identificador sea entero o flotante
                            //Verificar que exista el identificador
                            reportarErrorNoExisteSimbolo(n);
                            //Obtener el tipo
                            Simbolo simbolo = buscarSimbolo(n);
                            String tipo;
                            String temp2;
                            String temp;
                            if(simbolo != null){
                                
                                
                                tipo = simbolo.getTipo();
                                if(tipo.equals("int") || tipo.equals("float")){
                                    if (tipo.equals("float")){
                                        temp2 = registroTemporalF();
                                        temp = registroTemporalF();
                                    } else {
                                        temp2 = registroTemporalI();
                                        temp = registroTemporalI();
                                    }
                                    C3D.append("\n" + temp2 + " = " + "1\n");
                                    C3D.append("\n" + temp + " = " + simbolo.getSimbolo() + " + " + temp2 + ";\n");
                                    
                                    RESULT =  temp + "::" + simbolo.getTipo() + "::"  + (nleft +1) + "::" + nright; 
                                }else{
                                    //Reportar el error
                                   System.err.println(String.format(
                                    "Error Semantico: El identificador para la operacion de incremento postfijo en la linea %s columna %s debe ser entero o flotante.", 
                                    (nleft +1), nright
                                    ));
                                    erroresSemanticos++;
                                    parser.erroresSemanticos++;
                                    RESULT = "null::null::" + (nleft + 1) + "::" + nright;
                                }
                            }else{
                                RESULT = "null::null::" + (nleft + 1) + "::" + nright;
                            }
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("postfix_expression",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // postfix_expression ::= identifier decrement_operator 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Decremento (--)"); 
                        //Verificar que el identificador sea entero o flotante
                            //Verificar que exista el identificador
                            reportarErrorNoExisteSimbolo(n);
                            //Obtener el tipo
                            Simbolo simbolo = buscarSimbolo(n);
                            String tipo;
                            String temp2;
                            String temp;
                            if(simbolo != null){
                                
                                //Verificar que sea entero o flotante
                                tipo = simbolo.getTipo();
                                if(tipo.equals("int") || tipo.equals("float")){
                                    if (tipo.equals("float")){
                                        temp2 = registroTemporalF();
                                        temp = registroTemporalF();
                                    } else {
                                        temp2 = registroTemporalI();
                                        temp = registroTemporalI();
                                    }
                                    C3D.append("\n" + temp2 + " = " + "1\n");
                                    C3D.append("\n" + temp + " =  " + simbolo.getSimbolo() + " - " + temp2 + ";\n");
                                    RESULT = temp + "::" + simbolo.getTipo() + "::"  + (nleft +1) + "::" + nright; 
                                }else{
                                    //Reportar el error
                                   System.err.println(String.format(
                                    "Error Semantico: El identificador para la operacion de decremento postfijo en la linea %s columna %s debe ser entero o flotante.", 
                                    (nleft +1), nright
                                    ));
                                    erroresSemanticos++;
                                    parser.erroresSemanticos++;
                                    RESULT = "null::null::" + (nleft + 1) + "::" + nright;
                                }
                            }else{
                                RESULT = "null::null::" + (nleft + 1) + "::" + nright;
                            }
                    
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("postfix_expression",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // logical_expresion_and ::= logical_expresion_and and_operator logical_expresion_or 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Operador logico AND (@)"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String parteIzq2;
                if (partesE1.length > 4) {
                    parteIzq2 = partesE1[4];  // Esto es porque si son varias operaciones tipo  5 > 3 ~ 2 < 4 entonces puede pasar a la parte donde ya mando todo eso
                } else { // sino quiere decir que es algo bsico o pequeo por lo tanto es ms sencillo que y evita el error de salirme del rango
                    parteIzq2 = partesE1[0];
                }

                String parteDer2;
                if (partesE2.length > 4) {
                    parteDer2 = partesE2[4];
                } else {
                    parteDer2 = partesE2[0];
                }
                System.out.println("Parte der en AND: " + parteDer2);
                System.out.println("Parte izq en AND: " + parteIzq2);
                String validacion = validacionLogicaSoloBoleanos("AND", "@", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);

                if(!esTemporal(parteIzq2) && esLiteralVerdadero(parteIzq2)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq2 + ";\n");
                    parteIzq2 = tempIzq;
                }
                
                if(!esTemporal(parteDer2) && esLiteralVerdadero(parteDer2)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer2 + ";\n");
                    parteDer2 = tempDer;
                }
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq2 + " @ " + parteDer2 + ";\n");            
                RESULT = validacion + "::" + temp;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("logical_expresion_and",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // logical_expresion_and ::= logical_expresion_or 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("logical_expresion_and",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // logical_expresion_or ::= logical_expresion_or or_operator relational_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Operador logico OR (~)"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionLogicaSoloBoleanos("OR", "~", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq2;
                if (partesE1.length > 4) {
                    parteIzq2 = partesE1[4];  // Esto es porque si son varias operaciones tipo  5 > 3 ~ 2 < 4 entonces puede pasar a la parte donde ya mando todo eso
                } else { // sino quiere decir que es algo bsico o pequeo por lo tanto es ms sencillo que y evita el error de salirme del rango
                    parteIzq2 = partesE1[0];
                }

                String parteDer2;
                if (partesE2.length > 4) {
                    parteDer2 = partesE2[4];
                } else {
                    parteDer2 = partesE2[0];
                }

                if(!esTemporal(parteIzq2) && esLiteralVerdadero(parteIzq2)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq2 + ";\n");
                    parteIzq2 = tempIzq;
                }
                
                if(!esTemporal(parteDer2) && esLiteralVerdadero(parteDer2)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer2 + ";\n");
                    parteDer2 = tempDer;
                }
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq2 + " ~ " + parteDer2 + ";\n");            
                RESULT = validacion + "::" + temp;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("logical_expresion_or",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // logical_expresion_or ::= relational_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("logical_expresion_or",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // relational_expression ::= arithmetic_expression greater_operator arithmetic_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Mayor que (>) reconocido"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionRelacionalNoBoleanos("mayor que", ">", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq = partesE1[0];
                String parteDer = partesE2[0];

                if(!esTemporal(parteIzq) && esLiteralVerdadero(parteIzq)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq + ";\n");
                    parteIzq = tempIzq;
                }
                
                if(!esTemporal(parteDer) && esLiteralVerdadero(parteDer)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer + ";\n");
                    parteDer = tempDer;
                }
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq + " > " + parteDer + ";\n"); 
                RESULT = validacion + "::" + temp;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // relational_expression ::= arithmetic_expression less_operator arithmetic_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Menor que (<) reconocido"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionRelacionalNoBoleanos("menor que", "<", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq = partesE1[0];
                String parteDer = partesE2[0];

                if(!esTemporal(parteIzq) && esLiteralVerdadero(parteIzq)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq + ";\n");
                    parteIzq = tempIzq;
                }
                
                if(!esTemporal(parteDer) && esLiteralVerdadero(parteDer)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer + ";\n");
                    parteDer = tempDer;
                }
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq + " < " + parteDer + ";\n"); 
                RESULT = validacion + "::" + temp;           

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // relational_expression ::= arithmetic_expression greater_equal_operator arithmetic_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Mayor o igual que (>=) reconocido"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionRelacionalNoBoleanos("mayor o igual que", ">=", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq = partesE1[0];
                String parteDer = partesE2[0];

                if(!esTemporal(parteIzq) && esLiteralVerdadero(parteIzq)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq + ";\n");
                    parteIzq = tempIzq;
                }
                
                if(!esTemporal(parteDer) && esLiteralVerdadero(parteDer)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer + ";\n");
                    parteDer = tempDer;
                }                
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq + " >= " + parteDer + ";\n"); 
                RESULT = validacion + "::" + temp;
                
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // relational_expression ::= arithmetic_expression less_equal_operator arithmetic_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Menor o igual que (<=) reconocido"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionRelacionalNoBoleanos("menor o igual que", "<=", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq = partesE1[0];
                String parteDer = partesE2[0];

                if(!esTemporal(parteIzq) && esLiteralVerdadero(parteIzq)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq + ";\n");
                    parteIzq = tempIzq;
                }
                
                if(!esTemporal(parteDer) && esLiteralVerdadero(parteDer)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer + ";\n");
                    parteDer = tempDer;
                }                
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq + " <= " + parteDer + ";\n"); 
                RESULT = validacion + "::" + temp;
    
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // relational_expression ::= arithmetic_expression equal_operator arithmetic_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Igual que (==) reconocido"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionRelacionalConBoleanos("igual que", "==", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq = partesE1[0];
                String parteDer = partesE2[0];

                if(!esTemporal(parteIzq) && esLiteralVerdadero(parteIzq)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq + ";\n");
                    parteIzq = tempIzq;
                }
                
                if(!esTemporal(parteDer) && esLiteralVerdadero(parteDer)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer + ";\n");
                    parteDer = tempDer;
                }         
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq + " == " + parteDer + ";\n"); 
                RESULT = validacion + "::" + temp;
      
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // relational_expression ::= arithmetic_expression not_equal_operator arithmetic_expression 
            {
              Object RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object e1 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e2 = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Diferente que (!=) reconocido"); 
                String[] partesE1 = e1.toString().split("::");
                String[] partesE2 = e2.toString().split("::");
                String validacion = validacionRelacionalConBoleanos("diferente que", "!=", partesE1[0] , partesE2[0] ,partesE1[1], partesE2[1], partesE1[2], partesE2[2], partesE1[3], partesE2[3]);
                String parteIzq = partesE1[0];
                String parteDer = partesE2[0];

                if(!esTemporal(parteIzq) && esLiteralVerdadero(parteIzq)){ 
                    String tempIzq = registroTemporalI();
                    C3D.append("\n" + tempIzq + " = " + parteIzq + ";\n");
                    parteIzq = tempIzq;
                }
                
                if(!esTemporal(parteDer) && esLiteralVerdadero(parteDer)){ 
                    String tempDer = registroTemporalI();
                    C3D.append("\n" + tempDer + " = " + parteDer + ";\n");
                    parteDer = tempDer;
                }         
                String temp = registroTemporalI();
                C3D.append("\n" + temp + " = " + parteIzq + " != " + parteDer + ";\n"); 
                RESULT = validacion + "::" + temp;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // relational_expression ::= arithmetic_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Expresin aritmtica"); RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_expression",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // declaration_values ::= logical_expresion_and 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_values",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // declaration_values ::= CHAR_LITERAL 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e + "::char::" + (eleft + 1) + "::" + eright; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_values",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // declaration_values ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e + "::string::" + (eleft + 1) + "::" + eright; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_values",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // declaration ::= let_keyword int_keyword identifier delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: int sin valor con id "+ id); agregarSimbolo("int", id); C3D.append("\n" + "data_int " + id + ":\n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // declaration ::= let_keyword float_keyword identifier delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: float sin valor con id " + id); agregarSimbolo("float", id); C3D.append("\n" + "data_float " + id + ":\n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // declaration ::= let_keyword bool_keyword identifier delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: bool sin valor con id " + id); agregarSimbolo("bool", id); C3D.append("\n" + "data_bool " + id + ":\n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // declaration ::= let_keyword char_keyword identifier delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: char sin valor con id " + id); agregarSimbolo("char", id); C3D.append("\n" + "data_char " + id + ":\n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // declaration ::= let_keyword string_keyword identifier delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: string sin valor con id "+ id); agregarSimbolo("string", id); C3D.append("\n" + "data_string " + id + ":\n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // declaration ::= let_keyword int_keyword identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                /// Preguntarle al profe sobre esto 
                System.out.println("Declaracion: int con valor con el id "+ id); 
                //Verificar si el tipo de la expresin coincide con el del identificador
                 String[] partesOperador = e.toString().split("::");
                if(validacionAsignacion(id, "int", partesOperador[1], String.valueOf(idleft + 1), String.valueOf(idright))){
                    agregarSimbolo("int", id);
                }
                
                String parteUnica = partesOperador[0];
                System.out.println("Valor a guardar en int: " + parteUnica);

                // Si es literal, creamos un temporal
                if (esLiteral(parteUnica)) {
                    String tempLiteral = registroTemporalI();
                    C3D.append("\n" + tempLiteral + " = " + parteUnica + ";\n");
                    parteUnica = tempLiteral; 
                } 
                // Si NO es literal pero TAMPOCO es temporal, generamos uno extra
                else if (!esTemporal(parteUnica)) {
                    String tempExtra = registroTemporalI();
                    C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                    parteUnica = tempExtra;
                }

                // Ya con parteUnica siendo el temporal final:
                C3D.append("\n" + "data_int " + id + ":\n");
                C3D.append("\n" + id + " = " + parteUnica + ";\n");

                RESULT = id;


            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // declaration ::= let_keyword float_keyword identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: float con valor con el id "+ id); 

                //Verificar si el tipo de la expresin coincide con el del identificador
                 String[] partesOperador = e.toString().split("::");
                if(validacionAsignacion(id, "float", partesOperador[1], String.valueOf(idleft + 1), String.valueOf(idright))){
                    agregarSimbolo("float", id);
                }
                String parteUnica = partesOperador[0];
                System.out.println("Valor a guardar en float: " + parteUnica);

                // Si es un numero siempre hacemos temporal
                if (esLiteral(parteUnica)) {
                    String tempLiteral = registroTemporalF();
                    C3D.append("\n" + tempLiteral + " = " + parteUnica + ";\n");
                    parteUnica = tempLiteral; 
                } 
                
                // si es un temporal entonces lo asigno de una vez 
                else if (!continuouNo(parteUnica)) {
                    String tempExtra = registroTemporalF();
                    C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                    parteUnica = tempExtra;
                }

                // asignamos su id y lo mostramos
                C3D.append("\n" + "data_float " + id + ":\n");
                C3D.append("\n" + id + " = " + parteUnica + ";\n");

                RESULT = id;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // declaration ::= let_keyword bool_keyword identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: bool con valor con el id " + id); 
                 //Verificar si el tipo de la expresin coincide con el del identificador
                 String[] partesOperador = e.toString().split("::");
                if(validacionAsignacion(id, "bool", partesOperador[1], String.valueOf(idleft + 1), String.valueOf(idright))){
                    agregarSimbolo("bool", id);
                }
                String parteUnica;
                if (partesOperador.length > 4) {
                    // es una op anidada entonces se empieza a tomar desde ah
                    parteUnica = partesOperador[4];
                } else {
                    // sino entonces sigue siendo un numero 
                    parteUnica = partesOperador[0];
                }
                
                System.out.println("Valor a guardar en bool: " + parteUnica);

                // Solo creamos un temporal sino es un temporal 
                if (!continuouNo(parteUnica)) {
                    String tempExtra = registroTemporalI();
                    C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                    parteUnica = tempExtra;
                }

                C3D.append("\n" + "data_bool " + id + ":\n");
                C3D.append("\n" + id + " = " + parteUnica + ";\n");

                RESULT = id;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // declaration ::= let_keyword char_keyword identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: char con valor con el id " + id); 
                String[] partesOperador = e.toString().split("::");
                String guarda = partesOperador[0];
                if(validacionAsignacion(id, "char", partesOperador[1], String.valueOf(idleft + 1), String.valueOf(idright))){
                    agregarSimbolo("char", id);
                }
                String parteUnica = partesOperador[0];
                System.out.println("Valor a guardar en bool: " + parteUnica);

                // Si es un char siempre hacemos temporal
                if (esChar(parteUnica)) {
                    String tempLiteral = registroTemporalI();
                    C3D.append("\n" + tempLiteral + " = " + parteUnica + ";\n");
                    parteUnica = tempLiteral; 
                } 
                
                // si es un temporal entonces lo asigno de una vez 
                else if (!continuouNo(parteUnica)) {
                    String tempExtra = registroTemporalI();
                    C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                    parteUnica = tempExtra;
                }

                // asignamos su id y lo mostramos
                C3D.append("\n" + "data_char " + id + ":\n");
                C3D.append("\n" + id + " = " + parteUnica + ";\n");

                RESULT = id;
                //C3D.append("\n" + temp + " = " + partesOperador[2] + "\n");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // declaration ::= let_keyword string_keyword identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Declaracion: string con valor con el id " + id);
                String[] partesOperador = e.toString().split("::");
                if(validacionAsignacion(id, "string", partesOperador[1], String.valueOf(idleft + 1), String.valueOf(idright))){
                    agregarSimbolo("string", id);
                }
                String parteUnica = partesOperador[0];
                System.out.println("Valor a guardar en bool: " + parteUnica);

                // Si es un string siempre hacemos temporal
                if (esString(parteUnica)) {
                    String tempLiteral = registroTemporalI();
                    C3D.append("\n" + tempLiteral + " = " + parteUnica + ";\n");
                    parteUnica = tempLiteral; 
                } 
                
                // si es un temporal entonces lo asigno de una vez 
                else if (!continuouNo(parteUnica)) {
                    String tempExtra = registroTemporalI();
                    C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                    parteUnica = tempExtra;
                }

                // asignamos su id y lo mostramos
                C3D.append("\n" + "data_string " + id + ":\n");
                C3D.append("\n" + id + " = " + parteUnica + ";\n");

                RESULT = id;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // declaration ::= error delimiter 
            {
              Object RESULT =null;
		
               System.err.println("DECLARACION con error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // declaration ::= let_keyword error identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("No declaro el tipo error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // declaration ::= let_keyword int_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("No declaro el id error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // declaration ::= let_keyword float_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("No declaro el id error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // declaration ::= let_keyword bool_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("No declaro el id error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // declaration ::= let_keyword char_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("No declaro el id error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // declaration ::= let_keyword string_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("No declaro el id error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // declaration ::= let_keyword float_keyword identifier error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // declaration ::= let_keyword bool_keyword identifier error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // declaration ::= let_keyword int_keyword identifier assignment_operator declaration_values error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // declaration ::= let_keyword float_keyword identifier assignment_operator declaration_values error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // declaration ::= let_keyword bool_keyword identifier assignment_operator declaration_values error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // declaration ::= let_keyword char_keyword identifier assignment_operator declaration_values error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // declaration ::= let_keyword string_keyword identifier assignment_operator declaration_values error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // declaration ::= let_keyword error identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error falta el tipo"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // declaration ::= error int_keyword identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error falta el let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // declaration ::= error float_keyword identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error falta el let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // declaration ::= error bool_keyword identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error falta el let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // declaration ::= error char_keyword identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error falta el let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // declaration ::= error string_keyword identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error falta el let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // declaration ::= let_keyword int_keyword identifier assignment_operator error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en inicializacion de int"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // declaration ::= let_keyword float_keyword identifier assignment_operator error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en inicializacion de float"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // declaration ::= let_keyword bool_keyword identifier assignment_operator error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en inicializacion de bool"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // declaration ::= let_keyword char_keyword identifier assignment_operator error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en inicializacion de char"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // declaration ::= let_keyword string_keyword identifier assignment_operator error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en inicializacion de string"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // reassignment ::= identifier assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Reasignacin"); 
                //De momento es solo el print. Ya para el cdigo 3 direcciones si podra influir si se reasigna o no
                String[] partesOperador = e.toString().split("::");
                validacionReasignacion(id,  partesOperador[1], String.valueOf(idleft + 1), String.valueOf(idright));


                String parteUnica;
                if (partesOperador.length > 4) {
                    // es una op anidada entonces se empieza a tomar desde ah
                    parteUnica = partesOperador[4];
                } else {
                    // sino entonces sigue siendo un numero 
                    parteUnica = partesOperador[0];
                }
                System.out.println("Valor a reasignar: " + parteUnica); // esto es para debug

                // Solo creamos un temporal sino es un temporal 
                if (!continuouNo(parteUnica)) {
                    String tempExtra = registroTemporalI();
                    C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                    parteUnica = tempExtra;
                }

                C3D.append("\n" + id + " = " + parteUnica + ";\n");

                RESULT = id;


            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("reassignment",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // reassignment ::= identifier assignment_operator error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Reasignacin con error, declare un valor"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("reassignment",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // reassignment ::= error assignment_operator declaration_values delimiter 
            {
              Object RESULT =null;
		 System.err.println("Reasignacin con error, declare un id"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("reassignment",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // reassignment ::= identifier assignment_operator declaration_values error 
            {
              Object RESULT =null;
		 System.err.println("Reasignacin con error, falta el delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("reassignment",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 System.out.println("Declaracion: array int sin nada"); 
                    //Verificar que sea una operacion de enteros
                    String[] partesOperador = op.toString().split("::");
                    if(!(partesOperador[1].equals("int"))){
                        System.err.println(String.format(
                        "Error Semantico: La expresion aritmetica para indicar el tamanio del arrego debe ser de tipo int. Linea %s.", 
                        (idleft +1)
                        ));
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                    }else{
                        //Agregar el arreglo a la tabla. La funcin ya verifica si exista previamente
                        ArrayList<Simbolo> simbolos = new ArrayList<>();
                        agregarSimboloArray("arrayInt", id, partesOperador[0], simbolos);
                    }
                    
                    String parteUnica;
                    if (partesOperador.length > 4) {
                        // es una op anidada entonces se empieza a tomar desde ah
                        parteUnica = partesOperador[4];
                    } else {
                        // sino entonces sigue siendo un numero 
                        parteUnica = partesOperador[0];
                    }
                    
                    System.out.println("Valor a guardar en arr: " + parteUnica);

                    // Solo creamos un temporal sino es un temporal 
                    if (!continuouNo(parteUnica)) {
                        String tempExtra = registroTemporalI();
                        C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                        parteUnica = tempExtra;
                    }

                    C3D.append("\n" + "data_intArr " + id + ":\n");
                    C3D.append("\n" + id + " = " + parteUnica + ";\n");

                    RESULT = id;
 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // array_declaration ::= let_keyword int_keyword identifier error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // array_declaration ::= error int_keyword identifier left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // array_declaration ::= let_keyword error identifier left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta tipo"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // array_declaration ::= let_keyword int_keyword error left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta id"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // array_declaration ::= let_keyword int_keyword identifier left_bracket error right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta tamao"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ]"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // array_declaration ::= let_keyword int_keyword identifier error arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ["); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression right_bracket error 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // array_declaration ::= let_keyword char_keyword identifier left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 System.out.println("Declaracion: array char sin nada"); 
                    //Verificar que sea una operacion de enteros
                    String[] partesOperador = op.toString().split("::");
                    if(!(partesOperador[1].equals("int"))){
                        System.err.println(String.format(
                        "Error Semantico: La expresion aritmetica para indicar el tamanio del arrego debe ser de tipo int. Linea %s.", 
                        (idleft +1)
                        ));
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                    }else{
                        //Agregar el arreglo a la tabla. La funcin ya verifica si exista previamente
                        ArrayList<Simbolo> simbolos = new ArrayList<>();
                        agregarSimboloArray("arrayChar", id, partesOperador[0], simbolos);
                    }
                    String parteUnica;
                    if (partesOperador.length > 4) {
                        // es una op anidada entonces se empieza a tomar desde ah
                        parteUnica = partesOperador[4];
                    } else {
                        // sino entonces sigue siendo un numero 
                        parteUnica = partesOperador[0];
                    }
                    
                    System.out.println("Valor a guardar en arr cchar: " + parteUnica);

                    // Solo creamos un temporal sino es un temporal 
                    if (!continuouNo(parteUnica)) {
                        String tempExtra = registroTemporalI();
                        C3D.append("\n" + tempExtra + " = " + parteUnica + ";\n");
                        parteUnica = tempExtra;
                    }

                    C3D.append("\n" + "data_CharArr " + id + ":\n");
                    C3D.append("\n" + id + " = " + parteUnica + ";\n");

                    RESULT = id;


                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // array_declaration ::= error char_keyword identifier left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // array_declaration ::= let_keyword char_keyword error left_bracket arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta id"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // array_declaration ::= let_keyword char_keyword identifier left_bracket error right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta tamao"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // array_declaration ::= let_keyword char_keyword identifier left_bracket arithmetic_expression error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ]"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // array_declaration ::= let_keyword char_keyword identifier error arithmetic_expression right_bracket delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ["); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // array_declaration ::= let_keyword char_keyword identifier left_bracket arithmetic_expression right_bracket error 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // array_declaration ::= let_keyword char_keyword identifier error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int recleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int recright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object rec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 
                    System.out.println("Declaracion: array int con valores"); 
                    
                    // Lo dividimos para que as sea ms fcil acceder a lo que se ocupa
                    String[] elementosArray = rec.toString().split("::");
                    ArrayList<Simbolo> simbolosArreglo = new ArrayList<>();
                    
                    // Para cdigo 3D
                    C3D.append("\n" + "data_intArr " + id + ":\n");
                    
                    // Descomponer tamao
                    //Descomponer la operacin
                    String[] partesOperador = op.toString().split("::");
                    //Revvisar el tipo
                    if(!(partesOperador[1].equals("int"))){
                        System.err.println("Error Semantico: tamao debe ser int. Linea " + (idleft + 1));
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                    } else {
                        int indice = 0;
                        
                        
                        for (String elemento : elementosArray){
                            String[] partes = elemento.split(";;");  // recordar [valor, tipo, temporal]
                            
                            if(partes.length >= 3) {
                                String valor = partes[0];
                                String tipo = partes[1];
                                String temporal = partes[2];

                                //Vemos que sea del mismo tipo
                                if(tipo.equals("int")){
                                    simbolosArreglo.add(new Simbolo(valor, tipo));
                                    
                                    // Esto es para mostrar [0] = temporal;
                                    C3D.append(id + "[" + indice + "] = " + temporal + ";\n");
                                    indice++;
                                } else {
                                    System.err.println("Error Semantico: elemento " + valor + " debe ser int. Linea " + (idleft + 1));
                                    erroresSemanticos++;
                                    parser.erroresSemanticos++;
                                }
                            }
                        }
                        
                        agregarSimboloArray("arrayInt", id, partesOperador[0], simbolosArreglo);
                    }
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // array_declaration ::= error int_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // array_declaration ::= let_keyword error identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta tipo"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // array_declaration ::= let_keyword int_keyword error left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta id"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // array_declaration ::= let_keyword int_keyword identifier left_bracket error right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta tamao"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression error assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ]"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // array_declaration ::= let_keyword int_keyword identifier error arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ["); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block error 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta delimitador"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // array_declaration ::= let_keyword int_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block error right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en inicializacion de array"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // array_declaration ::= let_keyword char_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int recleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int recright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object rec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 
                    System.out.println("Declaracion: array char con valores"); 
                    String[] elementosArray = rec.toString().split("::");
                    ArrayList<Simbolo> simbolosArreglo = new ArrayList<>();

                    C3D.append("\n" + "data_CharArr " + id + ":\n");

                    String[] partesOperador = op.toString().split("::");
                    if(!(partesOperador[1].equals("int"))){
                        System.err.println(String.format(
                        "Error Semantico: La expresion aritmetica para indicar el tamanio del arrego debe ser de tipo int. Linea %s.", 
                        (idleft +1)
                        ));
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                    }else{
                        int indice = 0;

                        for (String elemento : elementosArray){
                            String[] partes = elemento.split(";;");
                            
                            if(partes.length >= 3){  
                                String valor = partes[0];
                                String tipo = partes[1];
                                String temporal = partes[2];

                                if(tipo.equals("char")){
                                    simbolosArreglo.add(new Simbolo(valor, tipo));
                                    C3D.append(id + "[" + indice + "] = " + temporal + ";\n");
                                    indice++;
                                } else {  
                                    System.err.println("Error Semantico: El tipo del elemento " + valor + " debe ser char para poder incluirlo en el arreglo " + id + " de la linea " + (idleft + 1) + ".");
                                    erroresSemanticos++;
                                    parser.erroresSemanticos++;
                                }
                            } else {  
                                System.err.println("Error Semantico: Formato incorrecto en elemento del arreglo " + id + " de la linea " + (idleft + 1) + ".");
                                erroresSemanticos++;
                                parser.erroresSemanticos++;
                            }
                        }

                        agregarSimboloArray("arrayChar", id, partesOperador[0], simbolosArreglo);
                    }
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // array_declaration ::= error char_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta let"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // array_declaration ::= let_keyword char_keyword error left_bracket arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta id"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // array_declaration ::= let_keyword char_keyword identifier left_bracket error right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta tamao"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // array_declaration ::= let_keyword char_keyword identifier left_bracket arithmetic_expression error assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ]"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // array_declaration ::= let_keyword char_keyword identifier error arithmetic_expression right_bracket assignment_operator left_block array_literals right_block delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en declaracion de array, falta ["); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // array_declaration ::= let_keyword char_keyword identifier left_bracket arithmetic_expression right_bracket assignment_operator left_block error right_block delimiter 
            {
              Object RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		 System.err.println("Error en inicializacion de array"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_declaration",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // array_literals ::= int_literal 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    String temp = registroTemporalI();
                    C3D.append("\n" + temp + " = " + e + ";\n");
                    RESULT = e + ";;int;;" + temp;  
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_literals",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // array_literals ::= CHAR_LITERAL 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    String temp = registroTemporalI();
                    C3D.append("\n" + temp + " = " + e + ";\n");
                    RESULT = e + ";;char;;" + temp;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_literals",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // array_literals ::= identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    reportarErrorNoExisteSimbolo(n);
                    Simbolo simbolo = buscarSimbolo(n);
                    if(simbolo != null){
                        RESULT = n + ";;" + simbolo.getTipo() + ";;" + n;  
                    }else{
                        RESULT = n + ";;null;;null";
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                    }
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_literals",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // array_literals ::= array_literals comma_keyword int_literal 
            {
              Object RESULT =null;
		int recleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int recright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object rec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    String temp = registroTemporalI();
                    C3D.append("\n" + temp + " = " + e + ";\n");
                    RESULT = rec + "::" + e + ";;int;;" + temp;  
                    System.out.println("DEBUG - resultado: " + RESULT);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_literals",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // array_literals ::= array_literals comma_keyword CHAR_LITERAL 
            {
              Object RESULT =null;
		int recleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int recright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object rec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        String temp = registroTemporalI();
                        C3D.append("\n" + temp + " = " + e + ";\n");
                        RESULT = rec + "::" + e + ";;char;;" + temp;
                        System.out.println("DEBUG - resultado: " + RESULT);

                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_literals",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // array_literals ::= array_literals comma_keyword identifier 
            {
              Object RESULT =null;
		int recleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int recright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object rec = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                        reportarErrorNoExisteSimbolo(n);
                        Simbolo simbolo = buscarSimbolo(n);
                        if(simbolo != null){
                            RESULT = rec + "::" + n + ";;"+ simbolo.getTipo();
                        }else{
                            RESULT = rec + "::" + n+";;null";
                            erroresSemanticos++;
                            parser.erroresSemanticos++;
                        }
                     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_literals",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // assign_elements_array ::= identifier left_bracket arithmetic_expression right_bracket assignment_operator arithmetic_expression delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int elementleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int elementright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object element = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Asignacion a elemento de arreglo"); 
                    String[] posicionArreglo = op.toString().split("::");
                    String[] elementoAsignado = element.toString().split("::");
                    agregarElementoArregloPosicionEspecifica(id.toString(), (idleft + 1), posicionArreglo[1], elementoAsignado[1], posicionArreglo[0], elementoAsignado[0]);
                        

                    String indiceArr = posicionArreglo[0];
                    String valor = elementoAsignado[0];
    
                    // si es un temporal entonces lo asigno de una vez 
                    if (!esTemporal(valor) && esLiteralVerdadero(valor)) {
                        String tempExtra = registroTemporalI();
                        C3D.append(tempExtra + " = " + valor + ";\n");
                        valor = tempExtra;
                    }

                    C3D.append("\n" + id + "[" +  indiceArr + "] = " + valor + ";\n");

                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_elements_array",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // assign_elements_array ::= identifier left_bracket arithmetic_expression right_bracket assignment_operator CHAR_LITERAL delimiter 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int elementleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int elementright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String element = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Asignacion a elemento de arreglo"); 
                   System.out.println(op);
                   System.out.println(id);
                    String[] posicionArreglo = op.toString().split("::");
                    agregarElementoArregloPosicionEspecifica(id.toString(), (idleft + 1), posicionArreglo[1], "char", posicionArreglo[0], element.toString());
                     

                    String indiceArr = posicionArreglo[0];
                    String tempChar = registroTemporalI();
                    C3D.append(tempChar + " = " + element + ";\n");
    
                    C3D.append(id + "[" + indiceArr + "] = " + tempChar + ";\n");
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assign_elements_array",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // array_access ::= identifier left_bracket arithmetic_expression right_bracket 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 //Verificar que exista el arreglo y que la expresin sea entero. Tipo arrayInt o arrayChar 
                    System.out.println(op);
                    String[] posicionArreglo = op.toString().split("::");
                    String elemento = accederElementoDeArreglo(id, posicionArreglo[0], posicionArreglo[1], (idleft + 1), idright); //valor::tipo::fila::columna
                    

                    RESULT = elemento; //Para guardarlo y proceder con la validacin posterior
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_access",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // input_statement ::= input_keyword identifier delimiter 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                    System.out.println("Input reconocido");
                    String temp = registroTemporalI();
                    C3D.append("\n" + "input " + " = " + temp + ";\n");
                    C3D.append("\n" + i + " = " + temp + ";\n");
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("input_statement",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // input_statement ::= input_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en input"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("input_statement",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // input_statement ::= error input_keyword identifier delimiter 
            {
              Object RESULT =null;
		 System.err.println("No se declaro el input"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("input_statement",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // input_statement ::= input_keyword identifier error 
            {
              Object RESULT =null;
		 System.err.println("Error falta el delimitador en input"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("input_statement",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // output_statement ::= output_keyword identifier delimiter 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                    System.out.println("Output id"); 
                    System.out.println("output reconocido");
                    String temp = registroTemporalI();
                    C3D.append("\n" + "output " + " = " + temp + ";\n");
                    C3D.append("\n" + i + " = " + temp + ";\n");
                    
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // output_statement ::= output_keyword int_literal delimiter 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 

                        String temp = registroTemporalI();
                        C3D.append("\n" + temp + " = " + i + ";\n");
                        C3D.append("\n" + "output " + " = " + temp + ";\n");
                        System.out.println("Output entero"); 
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // output_statement ::= output_keyword float_literal delimiter 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String f = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                        System.out.println("Output float"); 
                        String temp = registroTemporalF();
                         C3D.append("\n" + temp + " = " + f + ";\n");
                        C3D.append("\n" + "output " + " = " + temp + ";\n");
                        System.out.println("Output float");                        

                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // output_statement ::= output_keyword bool_literal delimiter 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                        String temp = registroTemporalI();
                        C3D.append("\n" + temp + " = " + b + ";\n");
                        C3D.append("\n" + "output " + " = " + temp + ";\n");
                        System.out.println("Output booleano");                        
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // output_statement ::= output_keyword CHAR_LITERAL delimiter 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                        String temp = registroTemporalI();
                        C3D.append("\n" + temp + " = " + c + ";\n");
                        C3D.append("\n" + "output " + " = " + temp + ";\n");
                        System.out.println("Output char");                      
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // output_statement ::= output_keyword STRING_LITERAL delimiter 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                        System.out.println("Output string"); 
                    
                        String temp = registroTemporalI();
                        C3D.append("\n" + temp + " = " + s + ";\n");
                        C3D.append("\n" + "output " + " = " + temp + ";\n");
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // output_statement ::= output_keyword error delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en output"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("output_statement",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // decide_of_helper ::= decide_keyword of_keyword left_parenthesis 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    //if (contadorIF > 1) {
    //    contadorIF--;
    //}
    String etiquetaEncabezado = "if_" + encabezado + "_encabezado";
    C3D.append("\n" + etiquetaEncabezado + ":\n");
    
    RESULT = String.valueOf(contadorIF);
    encabezado++;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of_helper",50, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // decide_of_left ::= decide_of_helper logical_expresion_and right_parenthesis minus_operator greater_operator 
            {
              Object RESULT =null;
		int helperleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int helperright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object helper = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		  

                        //Verificar que la expresin lgica sea booleana


                        String[] expresion = e.toString().split("::");
                        if(!(expresion[1].equals("bool"))){
                            System.err.println(String.format(
                            "Error Semantico: La expresion %s es de tipo %s. Debe ser de tipo bool para poder se utilizada como condicion en la estructura Decide Of. Linea %s.", 
                            expresion[0], expresion[1], eleft+1
                        ));
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                        }
                        

                        //Crear la tabla de smbolos
                        TablaDeSimbolos t = crearTablaDeSimbolos("decide of"); //Crear la nueva tabla para el decide of
                        apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta
                        // DECLARO PARAMAETROS EN DECIDE OF
                        String param;
                        if (expresion.length > 4 && expresion[4] != null) {
                            param = expresion[4];
                        } else {
                            param = expresion[0];
                        }
                        String etiquetaBloque = "if_bloque" + contadorBloque;
                        String etiquetaFin = "if_" + contadorIF + "_fin";
                        String etiquetaEncabezado = "if_" + encabezado + "_encabezado";
                        
                        C3D.append("if " + param + " goto " + etiquetaBloque + ":\n"); 
                        

                        C3D.append("goto " + etiquetaEncabezado + ";\n");
                        
                        C3D.append("\n" + etiquetaBloque + ":\n");
                        AgregarDireccion(etiquetaFin);
                        
                        contadorBloque++;
                        contadorIF++;


                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of_left",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // decide_of_left_and_content ::= decide_of_left left_block loop_content right_block 
            {
              Object RESULT =null;
		 
                                    desapilarTablaDeSimbolos(); //Desapilo aqu que ya se habra analizado ese bloque
                                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of_left_and_content",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // decide_of ::= decide_of_left_and_content end_keyword decide_keyword delimiter 
            {
              Object RESULT =null;
		 
            String etiquetaEncabezado = "if_" + encabezado + "_encabezado";
            C3D.append("\n" + etiquetaEncabezado + ":\n");
            C3D.append("goto if_1_fin;\n");
            
            C3D.append("\nif_1_fin:\n");
            System.out.println("decide of normal"); 
            eliminarDireccionBreak(); 
                
                
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // decide_of ::= decide_of_left_and_content elif_list end_keyword decide_keyword delimiter 
            {
              Object RESULT =null;
		 
                C3D.append("\nif_" + (contadorIF + 1) + "_encabezado:\n");
                C3D.append("goto if_1_fin;\n");
                C3D.append("\nif_1_fin:\n");
            System.out.println("decide of con varias condiciones"); 
            eliminarDireccionBreak();

            
            
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // decide_of ::= decide_of_left_and_content else_part end_keyword decide_keyword delimiter 
            {
              Object RESULT =null;
		
                C3D.append("goto if_1_fin;\n");
                C3D.append("\nif_" + (encabezado + 1) + "_encabezado:\n");
                
                C3D.append("goto if_1_fin;\n");
                
                C3D.append("\nif_1_fin:\n");
                
                System.out.println("decide of con else"); 
                eliminarDireccionBreak();
                
                
                
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // decide_of ::= decide_of_left_and_content elif_list else_part end_keyword decide_keyword delimiter 
            {
              Object RESULT =null;
		 

                C3D.append("goto if_" + (encabezado + 1) + "_encabezado;\n");

                C3D.append("\nif_" + (encabezado + 1) + "_encabezado:\n");
                
                C3D.append("goto if_1_fin;\n");
                
                C3D.append("\nif_1_fin:\n");



                System.out.println("decide of con varias condiciones y else"); 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // decide_of ::= decide_keyword of_keyword left_parenthesis error right_parenthesis minus_operator greater_operator left_block loop_content right_block end_keyword decide_keyword delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en condicion de decide of"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decide_of",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-12)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // elif_list ::= elif_part 
            {
              Object RESULT =null;
		
    UltimoElif = true;
    System.out.println("llegue al final");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("elif_list",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // elif_list ::= elif_list elif_part 
            {
              Object RESULT =null;
		
        UltimoElif = false;
        existeElif = true;
        System.out.println("me faltan elif");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("elif_list",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // elif_helper ::= left_parenthesis 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
    System.out.println("soy contador" + contadorIF);
    C3D.append("goto if_1_fin;\n");
    String etiquetaEncabezado = "if_" + encabezado + "_encabezado";
    C3D.append("\n" + etiquetaEncabezado + ":\n");
    
    RESULT = String.valueOf(encabezado);




              CUP$parser$result = parser.getSymbolFactory().newSymbol("elif_helper",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // elif_part_left ::= elif_helper logical_expresion_and right_parenthesis minus_operator greater_operator 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
                        //Verificar que la expresin lgica sea booleana
                        String[] expresion = e.toString().split("::");
                        if(!(expresion[1].equals("bool"))){
                            System.err.println(String.format(
                            "Error Semantico: La expresion %s es de tipo %s. Debe ser de tipo bool para poder se utilizada como condicion en la estructura Decide Of. Linea %s.", 
                            expresion[0], expresion[1], ileft+1
                        ));
                        erroresSemanticos++;
                        parser.erroresSemanticos++;
                        }
                        //Crear la tabla de smbolos
                        TablaDeSimbolos t = crearTablaDeSimbolos("elif"); //Crear la nueva tabla para el decide of
                        apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta

                            AgregarDireccion("endDecideOf");
    
                        
                        String param;
                        if (expresion.length > 4 && expresion[4] != null) {
                            param = expresion[4];
                        } else {
                            param = expresion[0];
                        }
                        String etiquetaBloque = "if_bloque" + contadorBloque;
                        String etiquetaEncabezado = "if_" + encabezado + "_encabezado";
                        
                        C3D.append("if " + param + " goto " + etiquetaBloque + ";\n");

                        System.out.println("wuju" + UltimoElif);
                        if (UltimoElif) {
                            C3D.append("goto if_1_fin;\n");
                        } else {
                            // Si hay ms elifs, ve al siguiente encabezado
                            encabezado++;
                            String etiquetaEncabezado2 = "if_" + encabezado + "_encabezado";
                            C3D.append("goto " + etiquetaEncabezado2 + ";\n");
                        }
                        
                        C3D.append("\n" + etiquetaBloque + ":\n");
                        
                        contadorBloque++;                     
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("elif_part_left",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // elif_part ::= elif_part_left left_block loop_content right_block 
            {
              Object RESULT =null;
		 System.out.println("elif"); 

            
            eliminarDireccionBreak();
                desapilarTablaDeSimbolos();
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("elif_part",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // else_helper ::= else_keyword 
            {
              Object RESULT =null;
		

    System.out.println("soy contador else" + contadorIF);
    C3D.append("goto if_1_fin;\n");
    String etiquetaEncabezado = "if_" + encabezado + "_encabezado";
    C3D.append("\n" + etiquetaEncabezado + ":\n");
    
    RESULT = String.valueOf(encabezado);


              CUP$parser$result = parser.getSymbolFactory().newSymbol("else_helper",52, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // else_part_left ::= else_helper minus_operator greater_operator 
            {
              Object RESULT =null;
		  
                    
                        //Crear la tabla de smbolos
                        TablaDeSimbolos t = crearTablaDeSimbolos("else"); //Crear la nueva tabla para el decide of
                        apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("else_part_left",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // else_part ::= else_part_left left_block loop_content right_block 
            {
              Object RESULT =null;
		 System.out.println("else"); desapilarTablaDeSimbolos();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("else_part",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // loop_helper ::= loop_keyword 
            {
              Object RESULT =null;
		
                String etiquetaInicioLoop = "loop_inicio_1";
                String etiquetaFinalLoop = "loop_fin_1";
                C3D.append("\n" + etiquetaInicioLoop + ":\n");
                AgregarDireccion(etiquetaFinalLoop);
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_helper",53, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // loop_left ::= loop_helper 
            {
              Object RESULT =null;
		 
             //Crear la tabla de smbolos

                TablaDeSimbolos t = crearTablaDeSimbolos("loop"); 
                apilarNuevaTablaDeSimbolos(t); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_left",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // loop ::= loop_left loop_content exit_keyword when_keyword logical_expresion_and delimiter end_keyword loop_keyword delimiter 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		 System.out.println("Loop");  
        //Verificar que la expresin lgica sea booleana
        String[] expresion = e.toString().split("::");
        if(!(expresion[1].equals("bool"))){
            System.err.println(String.format(
            "Error Semantico: La expresion %s es de tipo %s. Debe ser de tipo bool para poder se utilizada como condicion en la estructura loop. Linea %s.", 
            expresion[0], expresion[1], eleft+1
            ));
            erroresSemanticos++;
            parser.erroresSemanticos++;
         }


        //Agarro el ltimo temporal
        String valorFinal;
        String valor = expresion[expresion.length - 1];
        if(esTemporal(valor)){
            valorFinal = valor;
        } else {
            // Sino viene entonces lo que hago es asignarle un registro temporal
            valorFinal = expresion[0];
            if(!esTemporal(valorFinal)){
                String tmp = registroTemporalI();
                C3D.append(tmp + " = " + valorFinal + ";\n");
                valorFinal = tmp;
            }
        }

        String inicio = "loop_inicio_1";
        String fin = "loop_fin_1";
        AgregarDireccion(fin);
        C3D.append("if " + valorFinal + " goto " + fin + ";\n");
        C3D.append("goto " + inicio + ";\n");
        C3D.append(fin + ":\n");        


         
         desapilarTablaDeSimbolos();
         eliminarDireccionBreak();
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // loop ::= loop_left error exit_keyword when_keyword loop_keyword delimiter 
            {
              Object RESULT =null;
		 System.err.println("Error en contenido de loop");  desapilarTablaDeSimbolos();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // loop_content ::= statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_content",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // loop_content ::= break_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_content",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // loop_content ::= loop_content statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_content",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // loop_content ::= loop_content break_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_content",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // break_statement ::= break_keyword delimiter 
            {
              Object RESULT =null;
		 
                    System.out.println("break"); 
                    String direccion = obtenerDireccionActual();
                    //String etiquetaaAvanzar = ""
                    C3D.append("\n" + "goto " + direccion  + ";\n");

                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("break_statement",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // for_helperInicio ::= for_keyword 
            {
              Object RESULT =null;
		
            C3D.append("\n" + "for_inicio " + contadorFor + ":\n");
            RESULT = String.valueOf(contadorFor);
            //AgregarDireccion("for1_fin");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_helperInicio",54, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // for_loop_left ::= for_helperInicio reassignment step_keyword int_literal to_keyword int_literal do_keyword 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pasoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pasoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String paso = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int hastaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int hastaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String hasta = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
            String etiquetaFinFor = "fin_for" + contadorFor;
            AgregarDireccion(etiquetaFinFor);
            System.out.println("for loop int to"); 
            //Crear la tabla de smbolos
            String temp = registroTemporalI();
            C3D.append("\n" + temp + " = " + paso + ";\n");
            C3D.append("\n" + "for_stepDO = " + temp + ";\n");
            String temp2 = registroTemporalI();
            C3D.append("\n" + temp2 + " = " + hasta + ";\n");
            C3D.append("\n" + "for_hasta = " + hasta + ";\n");
            String temp3 = registroTemporalI();
            C3D.append("\n" + temp3 + " = " + var + " >= " + temp2 + ";\n");
            C3D.append("\n" + "if " + temp3 + " goto fin_for" + contadorFor + ";\n");
            String temp4 = registroTemporalI(); 
            C3D.append("\n" + temp4 + " = " + var + " + " + paso + ";\n");
            C3D.append("\n" + var + " = " + temp4 + ";\n");
            TablaDeSimbolos t = crearTablaDeSimbolos("for"); 
            apilarNuevaTablaDeSimbolos(t); 
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_loop_left",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // for_loop_left ::= for_helperInicio reassignment step_keyword int_literal downto_keyword int_literal do_keyword 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pasoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pasoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String paso = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int hastaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int hastaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String hasta = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("for loop int downto"); 
            //Crear la tabla de smbolos

            //Crear la tabla de smbolos
            String temp = registroTemporalI();
            C3D.append("\n" + temp + " = " + paso + ";\n");
            C3D.append("\n" + "for_stepDOWNto = " + temp + ";\n");
            String temp2 = registroTemporalI();
            C3D.append("\n" + temp2 + " = " + hasta + ";\n");
            C3D.append("\n" + "for_hasta = " + hasta + ";\n");
            String temp3 = registroTemporalI();
            C3D.append("\n" + temp3 + " = " + var + " <= " + temp2 + ";\n");
            C3D.append("\n" + "if " + temp3 + " goto fin_for" + contadorFor + ";\n");
            String temp4 = registroTemporalI(); 
            C3D.append("\n" + temp4 + " = " + var + " - " + paso + ";\n");
            C3D.append("\n" + var + " = " + temp4 + ";\n");

            TablaDeSimbolos t = crearTablaDeSimbolos("for"); 
            apilarNuevaTablaDeSimbolos(t); 
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_loop_left",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // for_loop_left ::= for_helperInicio reassignment step_keyword float_literal to_keyword float_literal do_keyword 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pasoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pasoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String paso = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int hastaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int hastaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String hasta = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 

            System.out.println("for loop float to"); 
            String temp = registroTemporalF();
            C3D.append("\n" + temp + " = " + paso + ";\n");
            C3D.append("\n" + "for_stepDO = " + temp + ";\n");
            String temp2 = registroTemporalF();
            C3D.append("\n" + temp2 + " = " + hasta + ";\n");
            C3D.append("\n" + "for_hasta = " + hasta + ";\n");
            String temp3 = registroTemporalF();
            C3D.append("\n" + temp3 + " = " + var + " >= " + temp2 + ";\n");
            C3D.append("\n" + "if " + temp3 + " goto fin_for" + contadorFor + ";\n");
            String temp4 = registroTemporalF(); 
            C3D.append("\n" + temp4 + " = " + var + " + " + paso + ";\n");
            C3D.append("\n" + var + " = " + temp4 + ";\n");

            //Crear la tabla de smbolos
                TablaDeSimbolos t = crearTablaDeSimbolos("for"); 
                apilarNuevaTablaDeSimbolos(t); 
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_loop_left",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // for_loop_left ::= for_helperInicio reassignment step_keyword float_literal downto_keyword float_literal do_keyword 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pasoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pasoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String paso = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int hastaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int hastaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String hasta = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
             System.out.println("for loop float downto"); 
            //Crear la tabla de smbolos
            String temp = registroTemporalF();
            C3D.append("\n" + temp + " = " + paso + ";\n");
            C3D.append("\n" + "for_stepDOWNto = " + temp + ";\n");
            String temp2 = registroTemporalF();
            C3D.append("\n" + temp2 + " = " + hasta + ";\n");
            C3D.append("\n" + "for_hasta = " + hasta + ";\n");
            String temp3 = registroTemporalF();
            C3D.append("\n" + temp3 + " = " + var + " <= " + temp2 + ";\n");
            C3D.append("\n" + "if " + temp3 + " goto fin_for" + contadorFor + ";\n");
            String temp4 = registroTemporalF(); 
            C3D.append("\n" + temp4 + " = " + var + " - " + paso + ";\n");
            C3D.append("\n" + var + " = " + temp4 + ";\n");
                TablaDeSimbolos t = crearTablaDeSimbolos("for"); 
                apilarNuevaTablaDeSimbolos(t); 
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_loop_left",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // for_loop ::= for_loop_left left_block loop_content right_block 
            {
              Object RESULT =null;
		 
            System.out.println("fin for"); desapilarTablaDeSimbolos();
            C3D.append("\n" + "goto for_inicio" + contadorFor + ":");
            C3D.append("\n" + "fin_for " + contadorFor + ":\n");
            eliminarDireccionBreak();
            contadorFor++;
            
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_loop",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // function_helper ::= int_keyword 
            {
              Object RESULT =null;
		 
    contadorTemporalINT = 1;
    contadorTemporalFLOAT = 1;
    C3D.append("\n" + "inicio_funcionInt" + contadorFuncINT + ":\n");
    funcInt = true;

    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_helper",55, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // function_helperF ::= float_keyword 
            {
              Object RESULT =null;
		 
    contadorTemporalINT = 1;
    contadorTemporalFLOAT = 1;
    C3D.append("\n" + "inicio_funcionFloat" + contadorFuncFLOAT + ":\n");
    funcFloat = true; 
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_helperF",56, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // function_helperB ::= bool_keyword 
            {
              Object RESULT =null;
		 
    contadorTemporalINT = 1;
    contadorTemporalFLOAT = 1;    
    C3D.append("\n" + "inicio_funcionBool" + contadorFuncBOOL + ":\n");
    funcBool = true; 
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_helperB",57, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // function_helperC ::= char_keyword 
            {
              Object RESULT =null;
		 
    contadorTemporalINT = 1;
    contadorTemporalFLOAT = 1;    
    C3D.append("\n" + "inicio_funcionChar" + contadorFuncCHAR + ":\n");
    funcChar = true; 
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_helperC",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // function_helperS ::= string_keyword 
            {
              Object RESULT =null;
		 
    contadorTemporalINT = 1;
    contadorTemporalFLOAT = 1;
    C3D.append("\n" + "inicio_funcionString" + contadorFuncSTRING + ":\n");
    funcString = true; 
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_helperS",59, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // function_left ::= function_helper identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    System.out.println("Crear tabla de smbolos para funcin int: " +id); 
                    TablaDeSimbolos t = crearTablaDeSimbolos(id); //Crear la nueva tabla
                    apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta

                    //Agregar a la tabla de funciones
                    agregarFuncion(id, "int", (idleft + 1));
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_left",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // function_left ::= function_helperF identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Crear tabla de smbolos para funcin flotante: " +id); 
                    TablaDeSimbolos t = crearTablaDeSimbolos(id); //Crear la nueva tabla
                    apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta

                    //Agregar a la tabla de funciones
                    agregarFuncion(id, "float", (idleft + 1));
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_left",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // function_left ::= function_helperB identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Crear tabla de smbolos para funcin bool: " +id); 
                    TablaDeSimbolos t = crearTablaDeSimbolos(id); //Crear la nueva tabla
                    apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta
                    
                    //Agregar a la tabla de funciones
                    agregarFuncion(id, "bool", (idleft + 1));
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_left",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // function_left ::= function_helperC identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Crear tabla de smbolos para funcin char: " +id); 
                    TablaDeSimbolos t = crearTablaDeSimbolos(id); //Crear la nueva tabla
                    apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta

                    //Agregar a la tabla de funciones
                    agregarFuncion(id, "char", (idleft + 1));
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_left",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // function_left ::= function_helperS identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 System.out.println("Crear tabla de smbolos para funcin string: " +id); 
                    TablaDeSimbolos t = crearTablaDeSimbolos(id); //Crear la nueva tabla
                    apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta

                    //Agregar a la tabla de funciones
                    agregarFuncion(id, "string", (idleft + 1));
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_left",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // function ::= function_left left_parenthesis right_parenthesis block 
            {
              Object RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object var = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                int cont = contadorTemporalINT - 1;
                if(funcInt == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcion" + contadorFuncINT + ":\n");
                contadorTemporalINT++;
                contadorFuncINT++;
                funcInt = false;
                }
                if ( funcFloat == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionFloat" + contadorFuncFLOAT + ":\n");
                contadorTemporalFLOAT++;
                contadorFuncFLOAT++;
                funcFloat = false;

                }
                if (funcBool == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionBool" + contadorFuncBOOL + ":\n");
                contadorTemporalINT++;
                contadorFuncBOOL++;
                funcBool = false;

                }
                if (funcChar == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionChar" + contadorFuncCHAR + ":\n");
                contadorTemporalINT++;
                contadorFuncCHAR++;
                funcChar = false;

                }
                if (funcString == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionString" + contadorFuncSTRING + ":\n");
                contadorTemporalINT++;
                contadorFuncSTRING++;
                funcString = false;
                }
                if (funcVoid == true){
                C3D.append("\n" + "fin_funcionVoid" + contadorFuncVOID + ":\n");
                contadorTemporalINT++;
                contadorFuncVOID++;
                funcVoid = false;

                }

                //Aqu desapilo
                desapilarTablaDeSimbolos();
                
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // function ::= function_left left_parenthesis params right_parenthesis block 
            {
              Object RESULT =null;
		 
                int cont = contadorTemporalINT - 1;
                if(funcInt == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcion" + contadorFuncINT + ":\n");
                contadorTemporalINT++;
                funcInt = false;
                }

                if ( funcFloat == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionFloat" + contadorFuncFLOAT + ":\n");
                contadorTemporalFLOAT++;
                contadorFuncFLOAT++;
                funcFloat = false;

                }

                if (funcBool == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionBool" + contadorFuncBOOL + ":\n");
                contadorTemporalINT++;
                contadorFuncBOOL++;
                funcBool = false;

                }
                if (funcChar == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionChar" + contadorFuncCHAR + ":\n");
                contadorTemporalINT++;
                contadorFuncCHAR++;
                funcChar = false;

                }
                if (funcString == true){
                C3D.append("\n" + "return " + "t" +cont + ":\n");
                C3D.append("\n" + "fin_funcionString" + contadorFuncSTRING + ":\n");
                contadorTemporalINT++;
                contadorFuncSTRING++;
                funcString = false;
                }
                if (funcVoid == true){
                C3D.append("\n" + "fin_funcionVoid" + contadorFuncVOID + ":\n");
                contadorTemporalINT++;
                contadorFuncVOID++;
                funcVoid = false;

                }

                desapilarTablaDeSimbolos();
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // function ::= function_left left_parenthesis error right_parenthesis block 
            {
              Object RESULT =null;
		 System.err.println("ERROR en parmetros de funcin "); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // params ::= param params_tail 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("params",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // params_tail ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("params_tail",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // params_tail ::= comma_keyword param params_tail 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("params_tail",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // param ::= int_keyword identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        agregarSimbolo("int", id); 
        agregarParametro(new Simbolo(id, "int"));
        C3D.append("\n" + "data_paramInt " +  id + ":\n");
        RESULT = id;
    
    ;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // param ::= float_keyword identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        agregarSimbolo("float", id); 
        agregarParametro(new Simbolo(id, "float"));
        C3D.append("\n" + "data_paramFloat " + id + ":\n");
        RESULT = id;

        
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // param ::= bool_keyword identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        agregarSimbolo("bool", id); 
        agregarParametro(new Simbolo(id, "bool"));
        C3D.append("\n" + "data_paramBool " + id + ":\n");
        RESULT = id;       
        
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // param ::= char_keyword identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        agregarSimbolo("char", id); 
        agregarParametro(new Simbolo(id, "char")); 
        C3D.append("\n" + "data_paramChar " + id + ":\n");
        RESULT = id; 

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // param ::= string_keyword identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        agregarSimbolo("string", id); 
        agregarParametro(new Simbolo(id, "string")); 
        C3D.append("\n" + "data_paramString " + id + ":\n");
        RESULT = id;
       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // return_statement ::= return_keyword delimiter 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String r = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("return vacio"); 
                    //Verificar que el retorno void coincida con una funcin void.
                    String tipoFuncion = tablaDeFunciones.obtenerTipoFuncion(funcionActual);
                    if(!(tipoFuncion.equals("void"))){
                        //Se reporta el error semntico. Se pretende retornar algo en una funcin void
                        System.err.println("Error Semantico: La funcion " + funcionActual + " es de tipo " + tipoFuncion+ ". El retorno debe de incluir un valor de este tipo. Linea " + (rleft + 1)); 
                         erroresSemanticos++;
                         parser.erroresSemanticos++;
                    }
                    
                  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_statement",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // return_statement ::= return_keyword logical_expresion_and delimiter 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String r = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("return expresion logica"); 
                    //Verificar que el retorno coincida.
                    String tipoFuncion = tablaDeFunciones.obtenerTipoFuncion(funcionActual);
                    String[] expresion = e.toString().split("::");
                    if(!(tipoFuncion.equals(expresion[1]))){
                        //Se reporta el error semntico. El retorno es diferente al tipo de la funcin
                        System.err.println("Error Semantico: La funcion " + funcionActual + " es de tipo " + tipoFuncion+ ". El retorno debe de incluir un valor de este tipo. Linea " + (rleft + 1)); 
                         erroresSemanticos++;
                         parser.erroresSemanticos++;
                    }
                  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_statement",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // function_call ::= identifier left_parenthesis right_parenthesis 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 System.out.println("Llamada a funcion sin argumentos"); 
               RESULT = id + "::" + tablaDeFunciones.obtenerTipoFuncion(id) + "::"+ (idleft + 1) + "::" + idright;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_call",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // function_call ::= identifier left_parenthesis args right_parenthesis 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 System.out.println("Llamada a funcion con argumentos"); 
                    //Verificaciones. En ar se tiene algo as por ejemplo a::null;;b::null;;1::int;;1.2::float donde es valor::tipo;;valor::tipo...
                    boolean existeLaFuncion = tablaDeFunciones.existeLaFuncion(id);
                    String retorno = id + "::null::" + (idleft + 1) + "::" + idright;
                    if(existeLaFuncion){
                        //Verificar que la cantidad de parmetros sea la misma
                        String[] parametros = ar.toString().split(";;");
                        boolean cantidadParametros = tablaDeFunciones.coincideLaCantidadDeParametros(id, parametros.length);
                        if(cantidadParametros){
                            //Verificar que el orden de los tipos sea el correcto
                            ArrayList<String> tipos = new ArrayList<>();

                            for (String elemento : parametros) {
                                String[] partes = elemento.split("::"); 
                                tipos.add(partes[1]);               
                            }

                            boolean coincidenLosParametros = tablaDeFunciones.coincidenLosTiposDeLosParametros(id, tipos);
                            if(coincidenLosParametros){
                                //Se pone el tipo de la funcin, ya pas las verificaciones
                                retorno = id + "::" + tablaDeFunciones.obtenerTipoFuncion(id) + "::"+ (idleft + 1) + "::" + idright;
                            }else{
                                System.err.println("Error Semantico: No coinciden los tipos de los parametros indicados en la funcion " + id + " Se esperaba: " + tablaDeFunciones.obtenerListaDeTiposDeParametros(id)+ " .Linea " + (idleft + 1)); 
                                erroresSemanticos++;
                                parser.erroresSemanticos++;
                            }
                        }else{
                            System.err.println("Error Semantico: La cantidad de parametros indicada en el llamado a la funcion " + id + " no es correcta. Se esperaban " + tablaDeFunciones.cantidadDeParametros(id)+ " .Linea " + (idleft + 1)); 
                            erroresSemanticos++;
                            parser.erroresSemanticos++;
                            
                        }
                    }else{
                         System.err.println("Error Semantico: No se ha declarado una funcion con el nombre " + id + " .Linea " + (idleft + 1)); 
                         erroresSemanticos++;
                         parser.erroresSemanticos++;
                    }
                    RESULT = retorno; //Se coloca el valor de retorno en el RESULT para posteriores validaciones   id de la funcion::tipo
                    
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_call",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // args ::= int_literal 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e + "::int"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // args ::= float_literal 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e + "::float"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // args ::= identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
            //Verificar que exista el identificador
            reportarErrorNoExisteSimbolo(n);
            //Obtener el tipo
            Simbolo simbolo = buscarSimbolo(n);
            if(simbolo != null){
                RESULT = n + "::" +simbolo.getTipo();
            }else{
                RESULT = n+"::null";
                erroresSemanticos++;
                parser.erroresSemanticos++;
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // args ::= array_access 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = e 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // args ::= STRING_LITERAL args_tail 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = e + "::string"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // args ::= CHAR_LITERAL args_tail 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = e + "::char"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // args ::= args comma_keyword int_literal 
            {
              Object RESULT =null;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = ar + ";;" + e + "::int";  
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // args ::= args comma_keyword float_literal 
            {
              Object RESULT =null;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = ar + ";;" + e + "::float";  
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // args ::= args comma_keyword identifier 
            {
              Object RESULT =null;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
            //Verificar que exista el identificador
            reportarErrorNoExisteSimbolo(n);
            //Obtener el tipo
            Simbolo simbolo = buscarSimbolo(n);
            if(simbolo != null){
                RESULT = ar+ ";;"+ n + "::" +simbolo.getTipo();
            }else{
                RESULT = ar + ";;" + n+"::null";
                erroresSemanticos++;
                parser.erroresSemanticos++;
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // args ::= args comma_keyword array_access 
            {
              Object RESULT =null;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = ar + ";;" + e;  
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // args ::= args comma_keyword STRING_LITERAL 
            {
              Object RESULT =null;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = ar + ";;" + e + "::string";  
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // args ::= args comma_keyword CHAR_LITERAL 
            {
              Object RESULT =null;
		int arleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int arright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ar = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String e = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = ar + ";;" + e + "::char";  
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // block ::= left_block statements right_block 
            {
              Object RESULT =null;
		 System.out.println("bloque con statement"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // block ::= left_block right_block 
            {
              Object RESULT =null;
		 System.out.println("bloque vacio"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // block ::= left_block error right_block 
            {
              Object RESULT =null;
		 System.err.println("bloque con error"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // statements ::= statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statements",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // statements ::= statements statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statements",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // statement ::= declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // statement ::= reassignment 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // statement ::= array_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // statement ::= assign_elements_array 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // statement ::= input_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // statement ::= output_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // statement ::= decide_of 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // statement ::= loop 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // statement ::= for_loop 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // statement ::= return_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // global_variables ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("global_variables",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // global_variables ::= global_variables declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("global_variables",48, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // principal_left ::= void_keyword principal_keyword left_parenthesis right_parenthesis 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		 //Para poder crear la tabla de smbolos
                            contadorTemporalINT = 1;
                            contadorTemporalFLOAT = 1;
                        C3D.append("\n" + "inicio principal:\n");
                        TablaDeSimbolos t = crearTablaDeSimbolos("Principal"); //Crear la nueva tabla
                        apilarNuevaTablaDeSimbolos(t); //Se coloca esta tabla como la actual y la que estaba en esa variable como la anterior de esta
                        //Agregar a la tabla de funciones
                        agregarFuncion("principal", "void", (idleft + 1));
                     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("principal_left",47, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // principal ::= principal_left block 
            {
              Object RESULT =null;
		 System.out.println("\n>> FUNCION PRINCIPAL reconocida"); desapilarTablaDeSimbolos(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("principal",46, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // functions ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("functions",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // functions ::= functions function 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("functions",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // program ::= global_variables functions principal 
            {
              Object RESULT =null;
		 System.out.println("\n========== PROGRAMA COMPLETO VALIDADO ==========\n"); 
         C3D.append("\n" + "fin principal\n");
         parser.sePuedeoNo();
         System.out.println("\nFUNCIONA EL 3 DIRECCIONES?\n");
         mostrarCodigo3Direcciones();
         System.out.println("\nEsto est al final de la produccin program");
         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",49, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
